<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"justinzm.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Pandas 是 Python 为解决数据分析而创建的，详情看官网 (https:&#x2F;&#x2F;pandas.pydata.org&#x2F;)。 在使用 pandas 之前，需要引进它，语法如下：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构之Pandas">
<meta property="og:url" content="https://justinzm.github.io/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BPandas/index.html">
<meta property="og:site_name" content="草根之明">
<meta property="og:description" content="Pandas 是 Python 为解决数据分析而创建的，详情看官网 (https:&#x2F;&#x2F;pandas.pydata.org&#x2F;)。 在使用 pandas 之前，需要引进它，语法如下：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.9lake.com/uPic/skLkuq.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/BARYJJ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/xdQV2m.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/I6kbBQ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/S7fUxU.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/QgbgGh.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/QDWKxW.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/2e6UxJ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/VTLIBT.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/jdsf3e.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/XfXao5.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/muybHz.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/2JPYOm.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/WlBbHU.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/FQlT2s.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/KhqXy1.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/FLv1w2.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/LFzLgC.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/fPxWA4.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/X2j3x0.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/6NY2dE.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/lllizT.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/wGaDsg.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/ybEt1C.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/UMxxyX.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/8Dgvyf.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/jqxXRs.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/BFKin1.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/e6vVmL.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Qucg5s.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/230g6w.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/dW5uC2.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/hLWFe2.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Jesdow.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/ZmpunJ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/fIiZ9h.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/WxjryM.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Nyeeeu.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/yhuWWZ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/5JH9rw.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/m7Kaxg.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/LWmLxI.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/yoj3Va.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Bzs3e4.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Nytc8P.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/p4H6td.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/48Pu5r.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/E4VBEz.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/9Zx3z7.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/z17Ln5.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/BWpKhG.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/psuEhC.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/InWtze.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/ygIAt6.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Kttq8W.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/XIctGd.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/WOCzY6.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/aMOHla.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/ZTIGoE.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/fqTCgr.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/WaxZZp.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/IYKcK4.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/TfUZyD.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/lSPGUJ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/AEp8yG.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Z9rp6r.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/i6WnhT.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/nQyzJR.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/RCvI9E.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/zRAv7a.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/h0DiGw.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/X40WuU.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/FCIuJv.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/obPARd.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/1zYJ6K.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/aA8YzM.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/i8fBGW.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/UyHwbm.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/HmNCN1.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/3urHvj.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/PQCq4S.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/YCIPsG.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/SxHDST.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/roWXRN.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/WN2BuG.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/LlxFB8.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/fgHf8i.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/1oQx1g.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/oy37su.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/IO6u4p.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/R0cl6M.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/e6e52i.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/DukrkI.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/tIMwmQ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/FHXTWu.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Iqzwtb.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/lc4WCf.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/NIgXqR.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/9qq3Oh.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/LQeh3U.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/COuAEk.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/l2eL53.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/QGeNbl.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/PYPFat.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/MBSKV8.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/c9Kb1k.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Kn1cWM.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/WCmBXk.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/fcQxXH.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/TFJohc.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/4ynBBL.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/weahpH.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/zd1W8V.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/1teLhF.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/urWYaU.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/tM0EIW.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/J6cyF9.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/Qnzeq3.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/vlLEzQ.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/eDp66D.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/ojKysH.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/JlrQJW.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/k5UEPK.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/1MEZmp.jpg">
<meta property="og:image" content="http://img.9lake.com/uPic/fPakDK.jpg">
<meta property="article:published_time" content="2019-12-15T03:39:49.000Z">
<meta property="article:modified_time" content="2022-09-18T07:33:43.756Z">
<meta property="article:author" content="草根之明">
<meta property="article:tag" content="项目管理、产品管理、区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.9lake.com/uPic/skLkuq.jpg">

<link rel="canonical" href="https://justinzm.github.io/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BPandas/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构之Pandas | 草根之明</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">草根之明</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">管理及技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BPandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构之Pandas
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-15 11:39:49" itemprop="dateCreated datePublished" datetime="2019-12-15T11:39:49+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-18 15:33:43" itemprop="dateModified" datetime="2022-09-18T15:33:43+08:00">2022-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Pandas 是 Python 为解决数据分析而创建的，详情看官网 (<a target="_blank" rel="noopener" href="https://pandas.pydata.org/)%E3%80%82">https://pandas.pydata.org/)。</a> 在使用 pandas 之前，需要引进它，语法如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pandas</span><br></pre></td></tr></table></figure>

<p>这样你就可以用 pandas 里面所有的内置方法 (build-in methods) 了，比如创建一维的 Series 和二维的 DataFrame。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series()</span><br><span class="line">pandas.DataFrame()</span><br></pre></td></tr></table></figure>

<p>但是每次写 pandas 字数有点多，通常我们给 pandas 起个别名 pd，用以下语法，这样所有出现 pandas 的地方都可以用 pd 替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>

<p>Pandas 里面的数据结构是「多维数据表」，学习它可以类比这 NumPy 里的「多维数组」。1&#x2F;2&#x2F;3 维的「多维数据表」分别叫做 Series (系列), DataFrame (数据帧) 和 Panel (面板)，和1&#x2F;2&#x2F;3 维的「多维数组」的类比关系如下。</p>
<p><img src="http://img.9lake.com/uPic/skLkuq.jpg" alt="skLkuq"></p>
<p>由于「系列」、「数据帧」和「面板」这些直译过来的中文名词听起来有些奇怪，在本帖还是直接用 Series, DataFrame 和 Panel。</p>
<p>对比 NumPy (np) 和 Pandas (pd) 每个维度下的数据结构，不难看出</p>
<pre><code>pd 多维数据表 = np 多维数组 + 描述
</code></pre>
<p>其中</p>
<ul>
<li>Series &#x3D; 1darray + index</li>
<li>DataFrame &#x3D; 2darray + index + columns</li>
<li>Panel &#x3D; 3darray + index + columns + item</li>
</ul>
<p>每个维度上的「索引」使得「多维数据表」比「多维数组」涵盖更多的信息，如下图，左边的 2d array 仅仅储存了一组数值 (具体代表什么意思却不知道)，而右边的 DataFrame 一看就知道这是平安银行和茅台从 2018-1-3 到 2019-1-3 的价格。</p>
<p><img src="http://img.9lake.com/uPic/BARYJJ.jpg" alt="BARYJJ"></p>
<p>学习 pandas 遵循的 Python 里「万物皆对象」的原则，既然把数据表当对象，我们就按着数据表的创建、数据表的存载、数据表的获取、数据表的合并和连接、数据表的重塑和透视、和数据表的分组和整合来盘一盘 Pandas。</p>
<h2 id="数据表的创建"><a href="#数据表的创建" class="headerlink" title="数据表的创建"></a>数据表的创建</h2><p>数据表有三大类型</p>
<ul>
<li>Series: 一维数据，类似于 python 中的基本数据的 list 或 NumPy 中的 1D array。Pandas 里最基本的数据结构</li>
<li>DataFrame: 二维数据，类似于 R 中的 data.frame 或 Matlab 中的 Tables。DataFrame 是 Series 的容器</li>
<li>Panel：三维数据。Panel 是 DataFrame 的容器</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><pre><code>最常见的数据类型是二维的 DataFrame，其中

每行代表一个示例 (instance)
每列代表一个特征 (feature)

DataFrame 可理解成是 Series 的容器，每一列都是一个 Series，或者 Series 是只有一列的 DataFrame。

Panel 可理解成是 DataFrame 的容器。
</code></pre>
<p>接下来我们用代码来创建 pandas 数据表，有两种方式：</p>
<ol>
<li>按步就班的用 pd.Series(), pd.DataFrame() 和 pd.Panel()</li>
<li>一步登天的用万矿里面的 WindPy API 读取</li>
</ol>
<h3 id="2-1-按部就班法"><a href="#2-1-按部就班法" class="headerlink" title="2.1 按部就班法"></a>2.1 按部就班法</h3><h4 id="一维Series"><a href="#一维Series" class="headerlink" title="一维Series"></a>一维Series</h4><p>创建 Series 只需用下面一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series( x, index=idx )</span><br></pre></td></tr></table></figure>
<p>其中 x 可以是</p>
<ol>
<li>列表 (list) </li>
<li>numpy 数组 (ndarray)</li>
<li>字典 (dict)</li>
</ol>
<p>x 是位置参数</p>
<p>index 是默认参数，默认值为 idx &#x3D; range(0, len(x))</p>
<h5 id="用列表"><a href="#用列表" class="headerlink" title="用列表"></a>用列表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([27.2, 27.65, 27.70, 28])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 27.20</span><br><span class="line">1 27.65</span><br><span class="line">2 27.70</span><br><span class="line">3 28.00</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>打印出来并不仅仅是列表里面的浮点数，每个浮点数前面还有一个索引，在本例中是 0, 1, 2, 3。</p>
<p>因此在创建 Series 时，如果不显性设定 index，那么 Python 给定一个默认从 0 到 N-1 的值，其中 N 是 x 的长度。</p>
<p>Series s 也是一个对象，用 dir(s) 可看出关于 Series 所有的属性和内置函数，其中最重要的是</p>
<ul>
<li><p>用 s.values 打印 s 中的元素</p>
</li>
<li><p>用 s.index 打印 s 中的元素对应的索引</p>
<p>  s.values</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([27.2 , 27.65, 27.7 , 28. ])</span><br></pre></td></tr></table></figure>
<pre><code>s.index
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RangeIndex(start=0, stop=4, step=1)</span><br></pre></td></tr></table></figure>

<p>不难发现，以上创建的 Series 和 numpy 数组比多了「索引」，但这种 0,1,2,3 的索引是在没有什么描述意义。实际上我们定义的 s 是海底捞在 2019 年 4 月 1 日到 2019 年 4 月 4 日的股价，那么用日期来当索引是不是更好些？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(&#x27;20190401&#x27;,periods=4)</span><br><span class="line">s2 = pd.Series( [27.2, 27.65, 27.70, 28], index=dates )</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 27.20</span><br><span class="line">2019-04-02 27.65</span><br><span class="line">2019-04-03 27.70</span><br><span class="line">2019-04-04 28.00</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>

<p>显然，s2 比 s 包含的信息更多，这是 s2 的索引是一组日期对象，数据类型是 datetime64，频率是 D (天)。</p>
<pre><code>s2.index
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#x27;2019-04-01&#x27;, &#x27;2019-04-02&#x27;, &#x27;2019-04-03&#x27;, &#x27;2019-04-04&#x27;],</span><br><span class="line">dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;D&#x27;)</span><br></pre></td></tr></table></figure>

<p>你甚至还可以给 s2 命名，就叫海底捞股价如何？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2.name = &#x27;海底捞股价&#x27;</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 27.20</span><br><span class="line">2019-04-02 27.65</span><br><span class="line">2019-04-03 27.70</span><br><span class="line">2019-04-04 28.00</span><br><span class="line">Freq: D, Name: 海底捞股价, dtype: float64</span><br></pre></td></tr></table></figure>

<h5 id="用-numpy-数组"><a href="#用-numpy-数组" class="headerlink" title="用 numpy 数组"></a>用 numpy 数组</h5><p>除了用列表，我们还可以用 numpy 数组来生成 Series。在下例中，我们加入缺失值 np.nan，并分析一下 Series 中另外 5 个属性或内置函数的用法：</p>
<ul>
<li>len: s 里的元素个数</li>
<li>shape: s 的形状 (用元组表示)</li>
<li>count: s 里不含 nan 的元素个数</li>
<li>unique: 返回 s 里不重复的元素</li>
<li>value_counts: 统计 s 里非 nan 元素的出现次数</li>
</ul>
<p>对照上面函数的用法，下面的输出一看就懂了吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series( np.array([27.2, 27.65, 27.70, 28, 28, np.nan]) )</span><br><span class="line">print( &#x27;The length is&#x27;, len(s) )</span><br><span class="line">print( &#x27;The shape is&#x27;, s.shape )</span><br><span class="line">print( &#x27;The count is&#x27;, s.count() )</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The length is 6</span><br><span class="line">The shape is (6,)</span><br><span class="line">The count is 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.unique()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([27.2 , 27.65, 27.7 , 28. , nan])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value_counts()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">28.00 2</span><br><span class="line">27.70 1</span><br><span class="line">27.65 1</span><br><span class="line">27.20 1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h5 id="用字典"><a href="#用字典" class="headerlink" title="用字典"></a>用字典</h5><p>创建 Series 还可以用字典。字典的「键值对」的「键」自动变成了 Series 的索引 (index)，而「值」自动变成了Series 的值 (values)。代码如下 (下列用 name 参数来对 s3 命名)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data_dict = &#123; &#x27;BABA&#x27;: 187.07, &#x27;PDD&#x27;: 21.83, &#x27;JD&#x27;: 30.79, &#x27;BIDU&#x27;: 184.77 &#125;</span><br><span class="line">s3 = pd.Series(data_dict, name=&#x27;中概股&#x27;)</span><br><span class="line">s3.index.name = &#x27;股票代号&#x27;</span><br><span class="line">s3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">股票代号</span><br><span class="line">BABA 187.07</span><br><span class="line">PDD 21.83</span><br><span class="line">JD 30.79</span><br><span class="line">BIDU 184.77</span><br><span class="line">Name: 中概股, dtype: float64</span><br></pre></td></tr></table></figure>
<p>给 s3 起名中概股是因为阿里巴巴 (BABA)、拼多多 (PDD)、京东 (JD) 和百度 (BIDU) 都是中国公司但在美国上市的。此外还可以给 index 命名为 ‘股票代号’。</p>
<p>现在假设我们的股票代号为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stock = [&#x27;FB&#x27;, &#x27;BABA&#x27;, &#x27;PDD&#x27;, &#x27;JD&#x27;]</span><br><span class="line">s4 = pd.Series( sdata, index=stock )</span><br><span class="line">s4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FB NaN</span><br><span class="line">BABA 160.0</span><br><span class="line">PDD 28.0</span><br><span class="line">JD 25.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>代号里多加了脸书 (FB)，而 sdata 字典中没有 FB 这个键，因此生成的 s4 在 FB 索引下对应的值为 NaN。再者，代号里没有百度 (BIDU)，因此 s4 里面没有 BIDU 对应的值 (即便 sdata 里面有)。</p>
<p>当两个 Series 进行某种操作时，比如相加，Python 会自动对齐不同 Series 的 index，如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3 + s4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BABA 320.0</span><br><span class="line">BIDU NaN</span><br><span class="line">FB NaN</span><br><span class="line">JD 50.0</span><br><span class="line">PDD 56.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>Series 是 Pandas 里面最基本的数据结构，但是对应每个索引只有一个元素 (比如一个日期对应一个股价)，因此 Series 处理不了每个索引对应多个元素 (比如一个日期对应一个开盘价、收盘价、交易量等等)。而 DataFrame 可以解决这个问题。</p>
<h4 id="二维-DataFrame"><a href="#二维-DataFrame" class="headerlink" title="二维 DataFrame"></a>二维 DataFrame</h4><p>创建 DataFrame 只需用下面一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame( x, index=idx, columns=col )</span><br></pre></td></tr></table></figure>

<p>其中 x 可以是</p>
<ol>
<li>二维列表 (list)</li>
<li>二维 numpy 数组 (ndarray)</li>
<li>字典 (dict)，其值是一维列表、numpy 数组或 Series</li>
<li>另外一个 DataFrame</li>
</ol>
<ul>
<li>x 是位置参数</li>
<li>index 是默认参数，默认值为 idx &#x3D; range(0, x.shape[0])</li>
<li>columns 是默认参数，默认值为 col &#x3D; range(0, x.shape[1])</li>
</ul>
<h5 id="用列表或-numpy-数组"><a href="#用列表或-numpy-数组" class="headerlink" title="用列表或 numpy 数组"></a>用列表或 numpy 数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># df1 = pd.DataFrame( [[1, 2, 3], [4, 5, 6]] )</span><br><span class="line">df1 = pd.DataFrame( np.array([[1, 2, 3], [4, 5, 6]]) )</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/xdQV2m.jpg" alt="xdQV2m"></p>
<p>在创建 DataFrame 时，如果不显性设定 index 和 columns 时，那么Python 给它们默认值，其中</p>
<ul>
<li>index &#x3D; 0 到 r-1，r 是 x 的行数</li>
<li>colmns &#x3D; 0 到 c-1，c 是 x 的列数</li>
</ul>
<h5 id="用对象为列表的字典"><a href="#用对象为列表的字典" class="headerlink" title="用对象为列表的字典"></a>用对象为列表的字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">symbol = [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;AAPL&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;, &#x27;WMT&#x27;]</span><br><span class="line">data = &#123;&#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;电商&#x27;, &#x27;科技&#x27;, &#x27;金融&#x27;, &#x27;金融&#x27;, &#x27;零售&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [176.92, 25.95, 172.97, 41.79, 196.00, 99.55],</span><br><span class="line">        &#x27;交易量&#x27;: [16175610, 27113291, 18913154, 10132145, 2626634, 8086946],</span><br><span class="line">        &#x27;雇员&#x27;: [101550, 175336, 100000, 60348, 36600, 2200000]&#125;</span><br><span class="line">df2 = pd.DataFrame( data, index=symbol )</span><br><span class="line">df2.name=&#x27;美股&#x27;</span><br><span class="line">df2.index.name = &#x27;代号&#x27;</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/I6kbBQ.jpg" alt="I6kbBQ"></p>
<p>字典的「键值对」的「键」自动变成了 DataFrame 的栏 (columns)，而「值」自动变成了 DataFrame 的值 (values)，而其索引 (index) 需要另外定义。</p>
<p>分别来看 df2 的 values, columns 和 index。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.values</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[&#x27;电商&#x27;, 176.92, 16175610, 101550],</span><br><span class="line">       [&#x27;电商&#x27;, 25.95, 27113291, 175336],</span><br><span class="line">       [&#x27;科技&#x27;, 172.97, 18913154, 100000],</span><br><span class="line">       [&#x27;金融&#x27;, 41.79, 10132145, 60348],</span><br><span class="line">       [&#x27;金融&#x27;, 196.0, 2626634, 36600],</span><br><span class="line">       [&#x27;零售&#x27;, 99.55, 8086946, 2200000]], dtype=object)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.columns</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;行业&#x27;, &#x27;价格&#x27;, &#x27;交易量&#x27;, &#x27;雇员&#x27;], dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;AAPL&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;, &#x27;WMT&#x27;],</span><br><span class="line">      dtype=&#x27;object&#x27;, name=&#x27;代号&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>查看 DataFrame</strong></p>
<p>我们可以从头或从尾部查看 DataFrame 的 n 行，分别用 df2.head() 和 df2.tail(n)，如果没有设定 n，默认值为 5 行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/S7fUxU.jpg" alt="S7fUxU"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.tail(3)</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/QgbgGh.jpg" alt="QgbgGh"></p>
<p><strong>统计 DataFrame</strong></p>
<p>我们用 df2.describe() 还可以看看 DataFrame 每栏的统计数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/QDWKxW.jpg" alt="QDWKxW"></p>
<p>函数 describe() 只对「数值型变量」有用 (没有对「字符型变量」行业栏做统计)，统计量分别包括个数、均值、标准差、最小值，25-50-75 百分数值，最大值。一般做数据分析第一步会用这个表大概看看</p>
<ul>
<li>数据是否有缺失值 (每个栏下的 count 是否相等)？</li>
<li>数据是否有异常值 (最小值 min 和最大值 max 是否太极端)？</li>
</ul>
<p><strong>升维 DataFrame</strong></p>
<p>我们用 MultiIndex.from_tuples() 还可以赋予 DataFrame 多层索引 (实际上增加了维度，多层索引的 DataFrame 实际上是三维数据)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df2.index = pd.MultiIndex.from_tuples( </span><br><span class="line">            [(&#x27;中国公司&#x27;,&#x27;BABA&#x27;), (&#x27;中国公司&#x27;,&#x27;JD&#x27;), </span><br><span class="line">             (&#x27;美国公司&#x27;,&#x27;AAPL&#x27;), (&#x27;美国公司&#x27;,&#x27;MS&#x27;), </span><br><span class="line">             (&#x27;美国公司&#x27;,&#x27;GS&#x27;), (&#x27;美国公司&#x27;,&#x27;WMT&#x27;)] )</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/2e6UxJ.jpg" alt="2e6UxJ"></p>
<p>在 MultiIndex.from_tuples() 中传递一个「元组的列表」，每个元组，比如 (‘中国公司’, ‘BABA’)，第一个元素中国公司是第一层 index，第二个元素BABA是第二层 index。</p>
<p>DataFrame 是 Series 的容器，那什么是 DataFrame 的容器？Panel</p>
<h4 id="三维-Panel"><a href="#三维-Panel" class="headerlink" title="三维 Panel"></a>三维 Panel</h4><p>创建 Panel 只需用下面一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Panel( x, item=itm, major_axis=n1, minor_axis=n2 )</span><br></pre></td></tr></table></figure>

<p>其中 x 可以是</p>
<ol>
<li>三维列表 (list)</li>
<li>三维 numpy 数组 (ndarray)</li>
<li>字典 (dict)，其值是 DataFrame</li>
</ol>
<ul>
<li>x 是位置参数</li>
<li>items 是默认参数 (axis 0)，默认值为 itm &#x3D; range(0, number of DataFrame)</li>
<li>major_axis 是默认参数 (axis 1)，默认值和 DataFrame 的默认 index 一样</li>
<li>minor_axis 是默认参数 (axis 2)，默认值和 DataFrame 的默认 columns 一样</li>
</ul>
<h5 id="用-numpy-数组-1"><a href="#用-numpy-数组-1" class="headerlink" title="用 numpy 数组"></a>用 numpy 数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pn = pd.Panel(np.random.randn(2, 5, 4))</span><br><span class="line">pn</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.panel.Panel&#x27;&gt;</span><br><span class="line">Dimensions: 2 (items) x 5 (major_axis) x 4 (minor_axis)</span><br><span class="line">Items axis: 0 to 1</span><br><span class="line">Major_axis axis: 0 to 4</span><br><span class="line">Minor_axis axis: 0 to 3</span><br></pre></td></tr></table></figure>

<p>Panel pn 含有 2 个 DataFrame，items 为 0, 1；每个 DataFrame 有 5 行 4 列，因此 major_axis 为 0,1,2,3,4，而 minor_axis 为 0,1,2,3。</p>
<h5 id="用对象为-DataFrame-的字典"><a href="#用对象为-DataFrame-的字典" class="headerlink" title="用对象为 DataFrame 的字典"></a>用对象为 DataFrame 的字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(&#x27;20190401&#x27;,periods=4)</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;开盘价&#x27;: [27.2, 27.65, 27.70, 28],</span><br><span class="line">        &#x27;收盘价&#x27;: [27.1, 27.55, 27.45, 28.1]&#125;</span><br><span class="line">df1 = pd.DataFrame( data, index=dates )</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;开盘价&#x27;: [367, 369.8, 378.2, 380.6],</span><br><span class="line">        &#x27;收盘价&#x27;: [369.5, 370.1, 380, 382.1]&#125;</span><br><span class="line">df2 = pd.DataFrame( data, index=dates )</span><br><span class="line"></span><br><span class="line">p_data = &#123;&#x27;海底捞&#x27; : df1, &#x27;腾讯&#x27; : df2&#125;</span><br><span class="line">pn = pd.Panel(p_data)</span><br><span class="line">pn</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.panel.Panel&#x27;&gt;</span><br><span class="line">Dimensions: 2 (items) x 4 (major_axis) x 2 (minor_axis)</span><br><span class="line">Items axis: 海底捞 to 腾讯</span><br><span class="line">Major_axis axis: 2019-04-01 00:00:00 to 2019-04-04 00:00:00</span><br><span class="line">Minor_axis axis: 开盘价 to 收盘价</span><br></pre></td></tr></table></figure>

<p>分析上面的 Panel pn</p>
<ul>
<li><p>有 2 个 DataFrame，items 为 ‘海底捞’ 和 ‘腾讯’</p>
</li>
<li><p>每个 DataFrame 有 4 行 2 列</p>
<ol>
<li>major_axis 从 2019-04-01 到 2019-04-04  </li>
<li>minor_axis 为 ‘开盘价’ 和 ‘收盘价’</li>
</ol>
</li>
</ul>
<p>让我们来查看两个 DataFrame 的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pn[&#x27;海底捞&#x27;]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/VTLIBT.jpg" alt="VTLIBT"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pn[&#x27;腾讯&#x27;]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/jdsf3e.jpg" alt="jdsf3e"></p>
<p>上面这种 Panel 类型的数据在量化投资中还蛮常见，比如我们需要 10 个股票在 1 年时期的 OHLC 价格 (Open, High, Low, Close)，Panel 的 Items, Major_axis 和 Minor_axis 正好可以存储这样的三维数据。如果 Panel 要废掉，那用什么容器来储存三维数据呢？</p>
<p>用多层索引 (Multi-index) 的 DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.concat([df1, df2])</span><br><span class="line">code = [&#x27;海底捞&#x27;, &#x27;腾讯&#x27;]</span><br><span class="line">midx = [ (c, d) for c in code for d in dates ] </span><br><span class="line">df.index =pd.MultiIndex.from_tuples( midx )</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/XfXao5.jpg" alt="XfXao5"></p>
<p>首先用 concat() 函数 (下帖的内容) 将 df1 和 df2 连接起来；再用「列表解析法」生成 midx，它是一个元组的列表，c 是股票代码，d 是日期；最后放入 MultiIndex.from_tuples() 生成有多层索引的 DataFrame。</p>
<h3 id="一步登天法"><a href="#一步登天法" class="headerlink" title="一步登天法"></a>一步登天法</h3><p>上节都是手敲一些数据来创建「多维数据表」的，现实中做量化分析时，数据量都会很大，一般都是从量化平台中或者下载好的 csv 中直接读取。本节介绍如何从量化平台「万矿」中读取数据来创建「多维数据表」的。</p>
<p>首先在 <a target="_blank" rel="noopener" href="https://www.windquant.com/">https://www.windquant.com</a> 注册一个账号，点击「研究」后在点开一个 Notebook 作为你的研究环境 (这是要夸奖一下万矿的 Notebook 体验真的不错，而且数据质量方面还有万德保证)。</p>
<p><img src="http://img.9lake.com/uPic/muybHz.jpg" alt="muybHz"></p>
<p>接着必须加载 WindPy，然后执行 w.start() 启动 API 接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from WindPy import *</span><br><span class="line">w.start()</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/2JPYOm.jpg" alt="2JPYOm"></p>
<p>WindPy 里面有几个获取数据的核心函数，分别是</p>
<ul>
<li>日期序列函数 wsd</li>
<li>多维数据函数 wss</li>
<li>行情数据函数 wsq</li>
<li>分钟序列数据函数 wsi</li>
</ul>
<h4 id="日期序列函数-wsd"><a href="#日期序列函数-wsd" class="headerlink" title="日期序列函数 wsd"></a>日期序列函数 wsd</h4><p>该函数支持股票、债券、基金、期货、指数等多种证券的基本资料、股东信息、市场行情、证券分析、预测评级、财务数据等各种数据，可以支持取单品种单指标、多品种单指标和单品种多指标的时间序列数据 (注：不支持多品种多指标)。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wsd(security, fields, startdate, enddate, options)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>startdate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>enddate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>options &#x3D; 一些特定设置</li>
</ul>
<h5 id="单品种单指标"><a href="#单品种单指标" class="headerlink" title="单品种单指标"></a>单品种单指标</h5><p>获取平安银行在 2019-04-01 到 2019-04-04 的收盘价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = &quot;000001.SZ&quot;</span><br><span class="line">factors = [&quot;close&quot;]</span><br><span class="line">startDate = &quot;2019-04-01&quot;</span><br><span class="line">endDate = &quot;2019-04-04&quot;</span><br><span class="line">data = w.wsd(code, factors, startDate, endDate, usedf=True )</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0, CLOSE</span><br><span class="line">2019-04-01 00:00:00.005 13.18</span><br><span class="line">2019-04-02 00:00:00.005 13.36</span><br><span class="line">2019-04-03 00:00:00.005 13.44</span><br><span class="line">2019-04-04 00:00:00.005 13.86)</span><br></pre></td></tr></table></figure>

<h6 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h6><pre><code>当 usedf=True 时返回元组

- 元组第一个元素为 ErrorCode，其为 0 时表示数据获取正常
- 元组第二个元素为获取的数据 DataFrame，其中 index 列为时间，columns 为参数 Fields 各指标
</code></pre>
<p>上面结果 errorcode &#x3D; 0，要获取 DataFrame 只需访问 data[1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[1]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WlBbHU.jpg" alt="WlBbHU"></p>
<h5 id="单品种多指标"><a href="#单品种多指标" class="headerlink" title="单品种多指标"></a>单品种多指标</h5><p>获取平安银行在 2019-04-01 到 2019-04-04 的开盘价、最低价、最高价和收盘价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = &quot;000001.SZ&quot;</span><br><span class="line">factors = &quot;open,low,high,close&quot;</span><br><span class="line">startDate = &quot;2019-04-01&quot;</span><br><span class="line">endDate = &quot;2019-04-04&quot;</span><br><span class="line">data = w.wsd(code, factors, startDate, endDate, usedf=True )</span><br><span class="line">data[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/FQlT2s.jpg" alt="FQlT2s"></p>
<h5 id="多品种单指标"><a href="#多品种单指标" class="headerlink" title="多品种单指标"></a>多品种单指标</h5><p>获取平安银行、万科、茅台在 2019-04-01 到 2019-04-04 的收盘价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = [&quot;000001.SZ&quot;,&quot;000002.SZ&quot;,&quot;600519.SH&quot;]</span><br><span class="line">factors = &quot;close&quot;</span><br><span class="line">startDate = &quot;2019-04-01&quot;</span><br><span class="line">endDate = &quot;2019-04-04&quot;</span><br><span class="line">data = w.wsd(code, factors, startDate, endDate, usedf=True )</span><br><span class="line">data[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/KhqXy1.jpg" alt="KhqXy1"></p>
<h4 id="多维数据函数-wss"><a href="#多维数据函数-wss" class="headerlink" title="多维数据函数 wss"></a>多维数据函数 wss</h4><p>该函数同样支持股票、债券、基金、期货、指数等多种证券的基本资料、股东信息、市场行情、证券分析、预测评级、财务数据等各种数据。但是 wss 支持取<strong>多品种多指标某个时间点</strong>的截面数据。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wss(security, fields, option)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>options &#x3D; 一些特定设置</li>
</ul>
<p>获取平安银行、万科、茅台在 2018-12-31 的收盘价、交易量、每股盈余和 profit&#x2F;GR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date = &quot;2018-12-31&quot;</span><br><span class="line">codes = [&quot;000001.SZ&quot;,&quot;000002.SZ&quot;,&quot;600519.SH&quot;]</span><br><span class="line">factors = &quot;close, volume, eps_basic, profittogr&quot;</span><br><span class="line">data = w.wss( codes, factors, </span><br><span class="line">              &quot;rptDate=&quot;+date+&quot;;currencyType=&quot;, usedf=True)</span><br><span class="line">data[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/FLv1w2.jpg" alt="FLv1w2"></p>
<p>如果要看财务数据，万矿是取每个季度最后一天作为报告期，如取 2018 年的四个定期报告数据，那报告期设置分别为：</p>
<ul>
<li>一季报：2018-03-31</li>
<li>半年报：2018-06-30</li>
<li>三季报：2018-09-30</li>
<li>年报：   2018-12-31</li>
</ul>
<p>本例 2018-12-31 是年报的数据。</p>
<h4 id="行情数据函数-wsq"><a href="#行情数据函数-wsq" class="headerlink" title="行情数据函数 wsq"></a>行情数据函数 wsq</h4><p>该函数支持股票、债券、基金、期货、指数等多种证券品种的实时行情数据。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wsq(security, fields, func=None)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>func &#x3D; 回调函数</li>
</ul>
<p>获取易方达深证 100ETF 里所有成分中的各种行情指标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ETF = w.wset(&quot;allfundhelddetail&quot;, &quot;rptdate=20181231;windcode=159901.OF&quot;)</span><br><span class="line">codes = ETF.Data[2]</span><br><span class="line">fields = &quot;rt_last,rt_vol,rt_chg,rt_pct_chg,rt_vwap,rt_ask1,rt_bid1&quot;</span><br><span class="line">data = w.wsq( codes, fields )</span><br><span class="line">            </span><br><span class="line">data = pd.DataFrame( data.Data, </span><br><span class="line">                     index=data.Fields, </span><br><span class="line">                     columns=data.Codes).T</span><br><span class="line">data.head(3).append(data.tail(3))</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/LFzLgC.jpg" alt="LFzLgC"></p>
<p>读者肯定好奇第一行代码怎么来的？这里 wset 是专门收集数据集信息的函数，万矿做的好的东西是又一套 GUI 帮你生成第一行代码，展示如下：</p>
<p><img src="http://img.9lake.com/uPic/fPxWA4.jpg" alt="fPxWA4"></p>
<p>点击「API 函数」下面的「WSET 数据集」会带给你以下界面。再选择「ETF 申购成分信息」。</p>
<p><img src="http://img.9lake.com/uPic/X2j3x0.jpg" alt="X2j3x0"></p>
<p>点击下一步得到</p>
<p><img src="http://img.9lake.com/uPic/6NY2dE.jpg" alt="6NY2dE"></p>
<p>看到没有第一行代码就这样生成了，获取数据的门槛迅速降低了好多。</p>
<h4 id="分钟序列数据函数-wsi"><a href="#分钟序列数据函数-wsi" class="headerlink" title="分钟序列数据函数 wsi"></a>分钟序列数据函数 wsi</h4><p>该函数获取选定证券品种的分钟线数据，包含基本行情和部分技术指标的分钟数据，分钟周期为 1-60 min，技术指标参数可以自定义设置。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wsi(security, fields, starttime = None, endtime = None, options = None)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>startdate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>enddate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>options &#x3D; 一些特定设置</li>
</ul>
<p>获取中金所 IF 股指期货当月连续合约 2019-04-01 09:30:00 开始至 2019-04-01 09:40:00 的 1 分钟数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">codes =&#x27;IF00.CFE&#x27;</span><br><span class="line">fields =&#x27;open, high, low, close&#x27;</span><br><span class="line">IF = w.wsi( codes, fields, &#x27;2019-04-01 09:30:00&#x27;, &#x27;2019-04-01 09:40:00&#x27;, &quot;&quot;, usedf=True )  </span><br><span class="line">IF[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/lllizT.jpg" alt="lllizT"></p>
<h3 id="数据表的存载"><a href="#数据表的存载" class="headerlink" title="数据表的存载"></a>数据表的存载</h3><p>本节讲数据表的「保存」和「加载」，数据的存载没什么技术含量</p>
<ul>
<li>保存只是为了下次再用处理好的 DataFrame</li>
<li>加载可以不用重新再定义 DataFrame</li>
</ul>
<p>DataFrame 可以被保存为 Excel, csv, SQL 和 HDF5 格式，其语句一看就懂，用 to_数据格式，具体如下：</p>
<ul>
<li>to_excel()</li>
<li>to_csv()</li>
<li>to_sql()</li>
<li>to_hdf()</li>
</ul>
<p>如果要加载某种格式的数据到 DataFrame 里，用 read_数据格式，具体如下：</p>
<ul>
<li>read_excel()</li>
<li>read_csv()</li>
<li>read_sql()</li>
<li>read_hdf()</li>
</ul>
<p>我们只用 excel 和 csv 格式举例。</p>
<h4 id="Excel-格式"><a href="#Excel-格式" class="headerlink" title="Excel 格式"></a>Excel 格式</h4><p>用 pd.to_excel 函数将 DataFrame 保存为 .xlsx 格式，并保存到 ‘Sheet1’ 中，具体写法如下：</p>
<pre><code>pd.to_excel( &#39;文件名&#39;，&#39;表名&#39; )
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6]]))</span><br><span class="line">df.to_excel(&#x27;pd_excel.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span><br></pre></td></tr></table></figure>

<p>用 pd.read_excel( ‘文件名’，’表名’ ) 即可加载该文件并存成 DataFrame 形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.read_excel(&#x27;pd_excel.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/wGaDsg.jpg" alt="wGaDsg"></p>
<h4 id="csv-格式"><a href="#csv-格式" class="headerlink" title="csv 格式"></a>csv 格式</h4><p>用 pd.to_csv 函数将 DataFrame 保存为 .csv 格式，注意如果 index 没有特意设定，最后不要把 index 值存到 csv 文件中。具体写法如下：</p>
<pre><code>pd.to_csv( &#39;文件名&#39;，index=False )
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#x27;Code&#x27;: [&#x27;BABA&#x27;, &#x27;00700.HK&#x27;, &#x27;AAPL&#x27;, &#x27;600519.SH&#x27;],</span><br><span class="line">        &#x27;Name&#x27;: [&#x27;阿里巴巴&#x27;, &#x27;腾讯&#x27;, &#x27;苹果&#x27;, &#x27;茅台&#x27;],</span><br><span class="line">        &#x27;Market&#x27;: [&#x27;US&#x27;, &#x27;HK&#x27;, &#x27;US&#x27;, &#x27;SH&#x27;],</span><br><span class="line">        &#x27;Price&#x27;: [185.35, 380.2, 197, 900.2],</span><br><span class="line">        &#x27;Currency&#x27;: [&#x27;USD&#x27;, &#x27;HKD&#x27;, &#x27;USD&#x27;, &#x27;CNY&#x27;]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df.to_csv(&#x27;pd_csv.csv&#x27;, index=False)</span><br></pre></td></tr></table></figure>

<p>用 pd.read_csv( ‘文件名’ ) 即可加载该文件并存成 DataFrame 形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.read_csv(&#x27;pd_csv.csv&#x27;)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ybEt1C.jpg" alt="ybEt1C"></p>
<p>如果一开始储存 df 的时候用 index&#x3D;True，你会发现加载完后的 df2 是以下的样子。</p>
<p><img src="http://img.9lake.com/uPic/UMxxyX.jpg" alt="UMxxyX"></p>
<p>df2 里面第一栏是 df 的 index，由于没有具体的 columns 名称，系统给它一个 “Unamed: 0”。因此在存储 df 的时候，如果 df.index 没有特意设定，记住要在 to_csv() 中把 index 设置为 <strong>False</strong>。</p>
<h3 id="数据表的索引和切片"><a href="#数据表的索引和切片" class="headerlink" title="数据表的索引和切片"></a>数据表的索引和切片</h3><p>由于索引&#x2F;切片 Series 跟 numpy 数组很类似，由于 Panel 在未来会被废掉，因此本节只专注于对 DataFrame 做索引和切片。本节以下面 df 为例做展示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">symbol = [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;AAPL&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;, &#x27;WMT&#x27;]</span><br><span class="line">data = &#123;&#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;电商&#x27;, &#x27;科技&#x27;, &#x27;金融&#x27;, &#x27;金融&#x27;, &#x27;零售&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [176.92, 25.95, 172.97, 41.79, 196.00, 99.55],</span><br><span class="line">        &#x27;交易量&#x27;: [16175610, 27113291, 18913154, 10132145, 2626634, 8086946],</span><br><span class="line">        &#x27;雇员&#x27;: [101550, 175336, 100000, 60348, 36600, 2200000]&#125;</span><br><span class="line">df = pd.DataFrame( data, index=symbol )</span><br><span class="line">df.name=&#x27;美股&#x27;</span><br><span class="line">df.index.name = &#x27;代号&#x27;</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/8Dgvyf.jpg" alt="8Dgvyf"></p>
<p>用不同颜色标注了 df 的 index, columns 和 values，可视图如下：</p>
<p><img src="http://img.9lake.com/uPic/jqxXRs.jpg" alt="jqxXRs"></p>
<p>DataFrame 的索引或切片可以基于标签 (label-based) ，也可以基于位置 (position-based)，不像 numpy 数组的索引或切片只基于位置。</p>
<p>DataFrame 的索引或切片有四大类：</p>
<ul>
<li><p>索引单元素：</p>
<ul>
<li>基于标签的 at</li>
<li>基于位置的 iat</li>
</ul>
</li>
<li><p>切片 columns：</p>
<ul>
<li>用 . 来切片单列</li>
<li>用 [] 来切片单列或多列</li>
<li>基于标签的 loc</li>
<li>基于位置的 iloc</li>
</ul>
</li>
<li><p>切片 index：</p>
<ul>
<li>用 [] 来切片单行或多行</li>
<li>基于标签的 loc</li>
<li>基于位置的 iloc</li>
</ul>
</li>
<li><p>切片 index 和 columns：</p>
<ul>
<li>基于标签的 loc</li>
<li>基于位置的 iloc</li>
</ul>
</li>
</ul>
<p>总体规律，基于标签就用 at 和 loc，基于位置就用 iat 和 iloc。下面我们来一类类分析：</p>
<h4 id="3-1-索引单元素"><a href="#3-1-索引单元素" class="headerlink" title="3.1 索引单元素"></a>3.1 索引单元素</h4><p>两种方法来索引单元素，情况 1 基于标签 at，情况 2 基于位置 iat。</p>
<ul>
<li>情况 1 - df.at[‘idx_i’, ‘attr_j’]</li>
<li>情况 2 - df.iat[i, j]</li>
</ul>
<p>Python 里的中括号 [] 会代表很多意思，比如单元素索引，多元素切片，布尔索引等等，因此让 Python 猜你用的 [] 意图会很低效。如果你想索引单元素，明明白白的用 at 和 iat 效率最高。</p>
<h5 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.at[&#x27;AAPL&#x27;,&#x27;价格&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.97</span><br></pre></td></tr></table></figure>
<p>用 at 获取「行标签」为 ‘AAPL’ 和「列标签」为 ‘价格’ 对应的元素。</p>
<h5 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a>情况 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iat[2,1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.97</span><br></pre></td></tr></table></figure>
<p>用 iat 获取第 3 行第 2 列对应的元素。</p>
<p>索引单元素的总结图：</p>
<p><img src="http://img.9lake.com/uPic/BFKin1.jpg" alt="BFKin1"></p>
<h4 id="3-2-切片-columns"><a href="#3-2-切片-columns" class="headerlink" title="3.2 切片 columns"></a>3.2 切片 columns</h4><h5 id="切片单个-columns"><a href="#切片单个-columns" class="headerlink" title="切片单个 columns"></a>切片单个 columns</h5><p>切片单个 columns 会返回一个 Series，有以下四种情况。情况 1 用点 .；情况 2 用中括号 []；情况 3 基于标签 loc，情况 4 基于位置 iloc。</p>
<ul>
<li>情况 1 - df.attr_i</li>
<li>情况 2 - df[‘attr_i’]</li>
<li>情况 3 - df.loc[:, ‘attr_i’]</li>
<li>情况 4 - df.iloc[:, i]</li>
</ul>
<p>情况 1 记住就可以了，没什么可说的。</p>
<p>情况 2 非常像二维 numpy 数组 arr 的切片，用 arr[i] 就能获取 arr 在「轴 0」上的第 i 个元素 (一个 1darray)，同理 df[‘attr_i’] 也能获取 df 的第 i 个 Series。</p>
<p>情况 3 和 4 的 loc 和 iloc 可类比于上面的 at 和 iat。带 i 的基于位置 (位置用整数表示，i 也泛指整数)，不带 i 的基于标签。里面的冒号 : 代表所有的 index (和 numpy 数组里的冒号意思相同)。</p>
<p>个人建议，如果追求简洁和方便，用 . 和 []；如果追求一致和清晰，用 loc 和 iloc。</p>
<h6 id="情况-1-1"><a href="#情况-1-1" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.价格</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 176.92</span><br><span class="line">JD 25.95</span><br><span class="line">AAPL 172.97</span><br><span class="line">MS 41.79</span><br><span class="line">GS 196.00</span><br><span class="line">WMT 99.55</span><br><span class="line">Name: 价格, dtype: float64</span><br></pre></td></tr></table></figure>
<p>用 . 获取「价格」那一栏下的 Series。</p>
<h6 id="情况-2-1"><a href="#情况-2-1" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;价格&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 176.92</span><br><span class="line">JD 25.95</span><br><span class="line">AAPL 172.97</span><br><span class="line">MS 41.79</span><br><span class="line">GS 196.00</span><br><span class="line">WMT 99.55</span><br><span class="line">Name: 价格, dtype: float64</span><br></pre></td></tr></table></figure>
<p>用 [] 获取「价格」属性下的 Series。</p>
<h6 id="情况-3"><a href="#情况-3" class="headerlink" title="情况 3"></a>情况 3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, &#x27;交易量&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 16175610</span><br><span class="line">JD 27113291</span><br><span class="line">AAPL 18913154</span><br><span class="line">MS 10132145</span><br><span class="line">GS 2626634</span><br><span class="line">WMT 8086946</span><br><span class="line">Name: 交易量, dtype: int64</span><br></pre></td></tr></table></figure>
<p>用 loc 获取「交易量」属性下的 Series。</p>
<h6 id="情况-4"><a href="#情况-4" class="headerlink" title="情况 4"></a>情况 4</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[:, 0]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 电商</span><br><span class="line">JD 电商</span><br><span class="line">AAPL 科技</span><br><span class="line">MS 金融</span><br><span class="line">GS 金融</span><br><span class="line">WMT 零售</span><br><span class="line">Name: 行业, dtype: object</span><br></pre></td></tr></table></figure>
<p>用 iloc 获取第 1 列下的 Series。</p>
<p>切片单个 columns 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/e6vVmL.jpg" alt="e6vVmL"></p>
<h4 id="切片多个-columns"><a href="#切片多个-columns" class="headerlink" title="切片多个 columns"></a>切片多个 columns</h4><p>切片多个 columns 会返回一个 sub-DataFrame (原 DataFrame 的子集)，有以下三种情况。情况 1 用中括号 []；情况 2 基于标签 loc，情况 3 基于位置 iloc。</p>
<ul>
<li>情况 1 - df[[‘attr_i’, ‘attr_j’]]</li>
<li>情况 2 - df.loc[:, ‘attr_i’:’attr_j’]</li>
<li>情况 3 - df.iloc[:, i:j]</li>
</ul>
<p>和切片单个 columns 相比：</p>
<ul>
<li>情况 1 用一个列表来储存一组属性 ‘attr_i’, ‘attr_j’，然后在放进中括号 [] 里获取它们</li>
<li>情况 2 用 ‘attr_i’:’attr_j’ 来获取从属性 i 到属性 j 的 sub-DataFrame</li>
<li>情况 3 用 i:j 来获取从列 i+1 到列 j 的 sub-DataFrame</li>
</ul>
<p>个人建议，如果追求简洁和方便，用 []；如果追求一致和清晰，用 loc 和 iloc。</p>
<h5 id="情况-1-2"><a href="#情况-1-2" class="headerlink" title="情况 1"></a>情况 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ [&#x27;雇员&#x27;, &#x27;价格&#x27;] ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Qucg5s.jpg" alt="Qucg5s"></p>
<p>用 [] 获取「雇员」和「价格」两个属性下的 sub-DataFrame。</p>
<h5 id="情况-2-2"><a href="#情况-2-2" class="headerlink" title="情况 2"></a>情况 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, &#x27;行业&#x27;:&#x27;交易量&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/230g6w.jpg" alt="230g6w"></p>
<p>用 loc 获取从属性 ‘行业’ 到 ‘交易量‘ 的 sub-DataFrame。</p>
<h5 id="情况-3-1"><a href="#情况-3-1" class="headerlink" title="情况 3"></a>情况 3</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[:, 0:2]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/dW5uC2.jpg" alt="dW5uC2"></p>
<p>用 iloc 获取第 1 和 2 列下的 sub-DataFrame。</p>
<p>切片多个 columns 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/hLWFe2.jpg" alt="hLWFe2"></p>
<h4 id="3-3-切片-index"><a href="#3-3-切片-index" class="headerlink" title="3.3 切片 index"></a>3.3 切片 index</h4><h5 id="切片单个-index"><a href="#切片单个-index" class="headerlink" title="切片单个 index"></a>切片单个 index</h5><p>切片<strong>单个</strong> index 有时会返回一个 Series，有以下两种情况。情况 1 基于标签 loc，情况 2 基于位置 iloc。</p>
<ul>
<li>情况 1 - df.loc[‘idx_i’, :]</li>
<li>情况 2 - df.iloc[i, :]</li>
</ul>
<p>切片<strong>单个</strong> index 有时会返回一个只有一行的 DataFrame，有以下两种情况。情况 3 用中括号 [] 加「位置」，情况 4 用中括号 [] 加「标签」。</p>
<ul>
<li>情况 3 - df[i:i+1]</li>
<li>情况 4 - df[‘idx_i’:’idx_i’]</li>
</ul>
<p>情况 1 和 2 的 loc 和 iloc 可类比于上面的 at 和 iat。带 i 的基于位置 (位置用整数表示，i 也泛指整数)，不带 i 的基于标签。里面的冒号 : 代表所有的 columns (和 numpy 数组里的冒号意思相同)。</p>
<p>情况 3 用中括号 [] 加「位置」，位置 i:i+1 有前闭后开的性质。如果要获取第 i+1 行，需要用 i:i+1。</p>
<p>情况 4 用中括号 [] 加「标签」，标签没有前闭后开的性质。如果要获取标签 i，只需要用 ‘idx_i’:’idx_i’。为什么不能只用 ‘idx_i’ 呢？原因是 Python 会把 df[‘idx_i’] 当成切片 columns，然后发现属性中没有 ‘idx_i’ 这一个字符，会报错的。</p>
<p>个人建议，只用 loc 和 iloc。情况 3 太麻烦，获取一行还要用 i:i+1。情况 4 的 df[‘idx_i’] 很容易和切片 columns 中的语句 df[‘attr_j’] 混淆。</p>
<h6 id="情况-1-3"><a href="#情况-1-3" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;GS&#x27;, : ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行业 金融</span><br><span class="line">价格 196</span><br><span class="line">交易量 2626634</span><br><span class="line">雇员 36600</span><br><span class="line">Name: GS, dtype: object</span><br></pre></td></tr></table></figure>

<p>用 loc 获取标签为 ‘GS‘ 的 Series。(GS &#x3D; Goldman Sachs &#x3D; 高盛)</p>
<h6 id="情况-2-3"><a href="#情况-2-3" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[ 3, : ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行业 金融</span><br><span class="line">价格 41.79</span><br><span class="line">交易量 10132145</span><br><span class="line">雇员 60348</span><br><span class="line">Name: MS, dtype: object</span><br></pre></td></tr></table></figure>

<p>用 iloc 获取第 4 行下的 Series。(MS &#x3D; Morgan Stanley &#x3D; 摩根斯坦利)</p>
<h6 id="情况-3-2"><a href="#情况-3-2" class="headerlink" title="情况 3"></a>情况 3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[1:2]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Jesdow.jpg" alt="Jesdow"></p>
<p>用 [1:2] 获取第 2 行的 sub-DataFrame (只有一行)。</p>
<h6 id="情况-4-1"><a href="#情况-4-1" class="headerlink" title="情况 4"></a>情况 4</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;JD&#x27;:&#x27;JD&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ZmpunJ.jpg" alt="ZmpunJ"></p>
<p>用 [‘JD’:’JD’] 获取标签为 ‘JD’ 的 sub-DataFrame (只有一行)。</p>
<p>切片单个 index 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/fIiZ9h.jpg" alt="fIiZ9h"></p>
<h5 id="切片多个-index"><a href="#切片多个-index" class="headerlink" title="切片多个 index"></a>切片多个 index</h5><p>切片多个 index 会返回一个 sub-DataFrame，有以下四种情况。情况 1 用中括号 [] 加「位置」，情况 2 用中括号 [] 加「标签」，情况 3 基于标签 loc，情况 4 基于位置 iloc。</p>
<ul>
<li>情况 1 - df[i:j]</li>
<li>情况 2 - df[‘idx_i’:’idx_j’]</li>
<li>情况 3 - df.loc[‘idx_i’:’idx_j’, :]</li>
<li>情况 4 - df.iloc[i:j, :]</li>
</ul>
<p>和切片单个 index 相比：</p>
<ul>
<li>情况 1 用 [i:j] 来获取行 i+1 到行 j 的 sub-DataFrame</li>
<li>情况 2 用 [‘idx_i’:’idx_j’] 来获取标签 i 到标签 j 的 sub-DataFrame</li>
<li>情况 3 用 loc 加 ‘idx_i’:’idx_j’ 来获取从标签 i 到标签 j 的 sub-DataFrame</li>
<li>情况 4 用 iloc 加 i:j 来获取从行 i+1 到行 j 的 sub-DataFrame</li>
</ul>
<p>个人建议，只用 loc 和 iloc。情况 1 和 2 的 df[] 很容易混淆中括号 [] 里的到底是切片 index 还是 columns。</p>
<h6 id="情况-1-4"><a href="#情况-1-4" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ 1:4 ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WxjryM.jpg" alt="WxjryM"></p>
<p>用 [1:4] 获取第 2 到 4 行的 sub-DataFrame。</p>
<h6 id="情况-2-4"><a href="#情况-2-4" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ &#x27;GS&#x27;:&#x27;WMT&#x27; ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Nyeeeu.jpg" alt="Nyeeeu"></p>
<p>用 [‘GS’:’WMT’] 获取标签从’GS’ 到 ‘WMT’ 的 sub-DataFrame。(WMT &#x3D; Walmart &#x3D; 沃尔玛)</p>
<h6 id="情况-3-3"><a href="#情况-3-3" class="headerlink" title="情况 3"></a>情况 3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;MS&#x27;:&#x27;GS&#x27;, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/yhuWWZ.jpg" alt="yhuWWZ"></p>
<p>用 loc 获取标签从 ‘MS‘ 到 ‘GS’ 的 sub-DataFrame。注意 ‘MS’:’GS’ 要按着 index 里面元素的顺序，要不然会返回一个空的 DataFrame，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;MS&#x27;:&#x27;JD&#x27;, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/5JH9rw.jpg" alt="5JH9rw"></p>
<p>情况 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[ 1:3, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/m7Kaxg.jpg" alt="m7Kaxg"></p>
<p>用 iloc 获取第 2 到 3 行的 sub-DataFrame。</p>
<p>切片多个 index 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/LWmLxI.jpg" alt="LWmLxI"></p>
<h4 id="3-4-切片-index-和-columns"><a href="#3-4-切片-index-和-columns" class="headerlink" title="3.4 切片 index 和 columns"></a>3.4 切片 index 和 columns</h4><p>切片多个 index 和 columns 会返回一个 sub-DataFrame，有以下两种情况。情况 1 基于标签 loc，情况 2 基于位置 iloc。</p>
<ul>
<li>情况 1 - df.loc[‘idx_i’:’idx_j’, ‘attr_k’:’attr_l’]</li>
<li>情况 2 - df.iloc[i:j, k:l]</li>
</ul>
<p>清清楚楚，明明白白，用 loc 和 iloc。</p>
<h6 id="情况-1-5"><a href="#情况-1-5" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;GS&#x27;:&#x27;WMT&#x27;, &#x27;价格&#x27;: ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/yoj3Va.jpg" alt="yoj3Va"></p>
<p>用 loc 获取行标签从 ‘GS‘ 到 ‘WMT’，列标签从’价格’到最后的 sub-DataFrame。</p>
<h6 id="情况-2-5"><a href="#情况-2-5" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[ :2, 1:3 ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Bzs3e4.jpg" alt="Bzs3e4"></p>
<p>用 iloc 获取第 1 到 2 行，第 1 到 2 列的 sub-DataFrame。</p>
<p>切片 index 和 columns 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/Nytc8P.jpg" alt="Nytc8P"></p>
<h4 id="3-5-高级索引"><a href="#3-5-高级索引" class="headerlink" title="3.5 高级索引"></a>3.5 高级索引</h4><p>高级索引 (advanced indexing) 可以用布尔索引 (boolean indexing) 和调用函数 (callable function) 来实现，两种方法都返回一组“正确”的索引，而且可以和 loc , iloc , [] 一起套用，具体形式有以下常见几种：</p>
<ul>
<li>df.loc[布尔索引, :] </li>
<li>df.iloc[布尔索引, :] </li>
<li>df[布尔索引] </li>
<li>df.loc[调用函数, :]  </li>
<li>df.iloc[调用函数, :] </li>
<li>df[调用函数]</li>
</ul>
<p>还有以下罕见几种：</p>
<ul>
<li>df.loc[:, 布尔索引] </li>
<li>df.iloc[:, 布尔索引] </li>
<li>df.loc[:, 调用函数]  </li>
<li>df.iloc[:, 调用函数]</li>
</ul>
<p>读者可以想一想为什么第一组形式「常见」而第二组形式「罕见」呢？(<strong>Hint: 看看两组里冒号 : 在不同位置，再想想 DataFrame 每一行和每一列中数据的特点</strong>)</p>
<h5 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h5><p>布尔索引就是用一个由布尔类型值组成的数组来选择元素的方法。</p>
<p>当我们要过滤掉雇员小于 100,000 人的公司，我们可以用 loc 加上布尔索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print( df.雇员 &gt;= 100000 )</span><br><span class="line">df.loc[ df.雇员 &gt;= 100000, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/p4H6td.jpg" alt="p4H6td"></p>
<p>一种更简便的表达形式是用 df[]，但是我个人不喜欢 []，总觉得会引起「到底在切片 index 还是 columns」的歧义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ df.雇员 &gt;= 100000 ]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/48Pu5r.jpg" alt="48Pu5r"></p>
<p>现在来看一个「罕见」例子，假如我们想找到所有值为整数型的 columns</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print( df.dtypes == &#x27;int64&#x27; )</span><br><span class="line">df.loc[ :, df.dtypes == &#x27;int64&#x27; ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/E4VBEz.jpg" alt="E4VBEz"></p>
<h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>调用函数是只能有一个参数 (DataFrame, Series) 并返回一组索引的函数。因为调用函数定义在 loc , iloc , [] 里面，因此它就像匿名函数。</p>
<p>当我们要找出交易量大于平均交易量的所有公司，我们可以用 loc 加上匿名函数 (这里 x 代表 df)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ lambda x: x.交易量 &gt; x.交易量.mean() , : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/9Zx3z7.jpg" alt="9Zx3z7"></p>
<p>在上面基础上再加一个条件 – 价格要在 100 之上 (这里 x 还是代表 df)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ lambda x: (x.交易量 &gt; x.交易量.mean()) &amp; (x.价格 &gt; 100), : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/z17Ln5.jpg" alt="z17Ln5"></p>
<p>最后来看看价格大于 100 的股票 (注意这里 x 代表 df.价格)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.价格.loc[ lambda x: x &gt; 100 ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 176.92</span><br><span class="line">AAPL 172.97</span><br><span class="line">GS 196.00</span><br><span class="line">Name: 价格, dtype: float64</span><br></pre></td></tr></table></figure>

<h4 id="3-6-多层索引"><a href="#3-6-多层索引" class="headerlink" title="3.6 多层索引"></a>3.6 多层索引</h4><p>在 Panel 那节已经提到过，多层索引可以将「低维数据」升维到「高维数据」，此外，多层索引还可以。。。</p>
<h5 id="多层索引-Series"><a href="#多层索引-Series" class="headerlink" title="多层索引 Series"></a>多层索引 Series</h5><p>首先定义一个 Series，注意它的 index 是一个二维列表，列表第一行 dates 作为第一层索引，第二行 codes 作为第二层索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">price = [190,32,196,192,200,189,31,30,199]</span><br><span class="line">dates = [&#x27;2019-04-01&#x27;]*3 + [&#x27;2019-04-02&#x27;]*2</span><br><span class="line">       +[&#x27;2019-04-03&#x27;]*2 + [&#x27;2019-04-04&#x27;]*2</span><br><span class="line">codes = [&#x27;BABA&#x27;,&#x27;JD&#x27;,&#x27;GS&#x27;,&#x27;BABA&#x27;,&#x27;GS&#x27;,&#x27;BABA&#x27;,&#x27;JD&#x27;,&#x27;JD&#x27;,&#x27;GS&#x27;]</span><br><span class="line"></span><br><span class="line">data = pd.Series( price, index=[ dates, codes ])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 BABA 190</span><br><span class="line">           JD 32</span><br><span class="line">           GS 196</span><br><span class="line">2019-04-02 BABA 192</span><br><span class="line">           GS 200</span><br><span class="line">2019-04-03 BABA 189</span><br><span class="line">           JD 31</span><br><span class="line">2019-04-04 JD 30</span><br><span class="line">           GS 199</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>这个 Series 存储了四天里若干股票的价格，2019-04-01 储存了阿里巴巴、京东和高盛的股价，2019-04-04 只储存了京东和高盛的股价。试想，如果不用多层索引的 Series，我们需要用一个 DataFrame 来存储在这样的数据，把 index 设置成 dates，把 colums 设置成 codes。</p>
<p>让我们看看 Series 的多层 index 是如何表示的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MultiIndex(levels=[[&#x27;2019-04-01&#x27;, &#x27;2019-04-02&#x27;, &#x27;2019-04-03&#x27;, &#x27;2019-04-04&#x27;],</span><br><span class="line">                   [&#x27;BABA&#x27;, &#x27;GS&#x27;, &#x27;JD&#x27;]],</span><br><span class="line">           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3],</span><br><span class="line">                   [0, 2, 1, 0, 1, 0, 2, 2, 1]])</span><br></pre></td></tr></table></figure>

<p>输出是一个 MultiIndex 的对象，里面有 levels 和 labels 二类信息。</p>
<h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><pre><code>索引既然分多层，那么肯定分「内层」和「外层」把，levels 就是描述层的先后的。levels 是一个二维列表，每一行只存储着「唯一」的索引信息：

- dates 是第一层索引，有 4 个「唯一」元素
- codes 是第二层索引，有 3 个「唯一」元素

但是 data 里面有九行啊，4 个 dates 和 3 个 codes 怎么能描述这九行信息呢？这就需要 labels 了。labels 也是一个二维列表：

- 第一行储存 dates 每个元素在 data 里的位置索引
- 第二行储存 codes 每个元素在 data 里的位置索引
</code></pre>
<p>用 [] 加第一层索引可以获取第一层信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[&#x27;2019-04-02&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BABA 192</span><br><span class="line">GS   200</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>同理，用 loc 加第一层索引也可以切片获取第一层信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[&#x27;2019-04-02&#x27;:&#x27;2019-04-04&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-04-02 BABA 192</span><br><span class="line">           GS 200</span><br><span class="line">2019-04-03 BABA 189</span><br><span class="line">           JD 31</span><br><span class="line">2019-04-04 JD 30</span><br><span class="line">           GS 199</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>此外，切片还可以在不同层上进行，下面 loc  中的冒号 : 表示第一层所有元素，‘GS’ 表示第二层标签为 ‘GS’。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[ :, &#x27;GS&#x27; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 196</span><br><span class="line">2019-04-02 200</span><br><span class="line">2019-04-04 199</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h5 id="多层索引-DataFrame"><a href="#多层索引-DataFrame" class="headerlink" title="多层索引 DataFrame"></a>多层索引 DataFrame</h5><p>Series 只有 index，上面刚介绍完多层 index，DataFrame 有 index 和 columns，它们可以设置成多层吗？下面代码用 MultiIndex 函数创建「多层 index 」midx 和「多层columns」mcol。</p>
<p>midx 和 mcol 都是对象，各种都有 levels, labels, names 等性质。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data = [ [&#x27;电商&#x27;, 101550, 176.92, 16175610], </span><br><span class="line">         [&#x27;电商&#x27;, 175336, 25.95, 27113291], </span><br><span class="line">         [&#x27;金融&#x27;, 60348, 41.79, 10132145], </span><br><span class="line">         [&#x27;金融&#x27;, 36600, 196.00, 2626634] ]</span><br><span class="line"></span><br><span class="line">midx = pd.MultiIndex( </span><br><span class="line">          levels=[[&#x27;中国&#x27;,&#x27;美国&#x27;],</span><br><span class="line">                  [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;GS&#x27;, &#x27;MS&#x27;]], </span><br><span class="line">          labels=[[0,0,1,1],[0,1,2,3]],</span><br><span class="line">          names=[&#x27;地区&#x27;, &#x27;代号&#x27;])</span><br><span class="line"></span><br><span class="line">mcol = pd.MultiIndex( </span><br><span class="line">          levels=[[&#x27;公司数据&#x27;,&#x27;交易数据&#x27;],</span><br><span class="line">                  [&#x27;行业&#x27;,&#x27;雇员&#x27;,&#x27;价格&#x27;,&#x27;交易量&#x27;]], </span><br><span class="line">          labels=[[0,0,1,1],[0,1,2,3]],</span><br><span class="line">          names=[&#x27;概括&#x27;,&#x27;细分&#x27;])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, index=midx, columns=mcol)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/BWpKhG.jpg" alt="BWpKhG"></p>
<p>这个 DataFrame 的 index 和 columns 都有两层，严格来说是个四维数据。下面看看如何进行「多层索引」的操作吧。</p>
<p>在第一层 columns 的 ‘公司数据’ 和第二层 columns 的 ‘行业’ 做索引，得到一个含两层 index 的 Series。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1st level-1 column, 2nd level-2 column</span><br><span class="line">df[&#x27;公司数据&#x27;,&#x27;行业&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">地区 代号</span><br><span class="line">中国 BABA 电商</span><br><span class="line">     JD   电商</span><br><span class="line">美国 GS   金融</span><br><span class="line">     MS   金融</span><br><span class="line">Name: (公司数据, 行业), dtype: object</span><br></pre></td></tr></table></figure>

<p>在第一层 index 的 ‘中国’ 做切片，得到一个含两层 columns 的 DataFrame。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[&#x27;中国&#x27;].loc[&#x27;BABA&#x27;:&#x27;JD&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/psuEhC.jpg" alt="psuEhC"></p>
<h5 id="调位-level"><a href="#调位-level" class="headerlink" title="调位 level"></a>调位 level</h5><p>如果你不喜欢 index level 的顺序，可用 swaplevel 将它们调位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.swaplevel(&#x27;地区&#x27;, &#x27;代号&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/InWtze.jpg" alt="InWtze"></p>
<p>如果你不喜欢 columns level 的顺序，也可用 swaplevel 将它们调位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns = df.columns.swaplevel(0,1)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ygIAt6.jpg" alt="ygIAt6"></p>
<h5 id="重设-index"><a href="#重设-index" class="headerlink" title="重设 index"></a>重设 index</h5><p>有时候，一个 DataFrame 的一个或者多个 columns 适合做 index，这时可用 set_index 将它们设置为 index，如果要将 index 还原成 columns，那么用 reset_index 。</p>
<p>看下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#x27;地区&#x27;: [&#x27;中国&#x27;, &#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;美国&#x27;],</span><br><span class="line">        &#x27;代号&#x27;: [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;],</span><br><span class="line">        &#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;电商&#x27;, &#x27;金融&#x27;, &#x27;金融&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [176.92, 25.95, 41.79, 196.00],</span><br><span class="line">        &#x27;交易量&#x27;: [16175610, 27113291, 10132145, 2626634],</span><br><span class="line">        &#x27;雇员&#x27;: [101550, 175336, 60348, 36600] &#125;</span><br><span class="line">df = pd.DataFrame( data )</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Kttq8W.jpg" alt="Kttq8W"></p>
<p>将「地区」和「代号」设置为第一层 index 和第二层 index。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.set_index( [&#x27;地区&#x27;,&#x27;代号&#x27;] )</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/XIctGd.jpg" alt="XIctGd"></p>
<p>将所有 index 变成 columns。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.reset_index()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WOCzY6.jpg" alt="WOCzY6"></p>
<h3 id="数据表的合并和连接"><a href="#数据表的合并和连接" class="headerlink" title="数据表的合并和连接"></a>数据表的合并和连接</h3><p>数据表可以按「键」合并，用 merge 函数；可以按「轴」来连接，用 concat 函数。</p>
<h4 id="4-1-合并"><a href="#4-1-合并" class="headerlink" title="4.1 合并"></a>4.1 合并</h4><p>按键 (key) 合并可以分「单键合并」和「多键合并」。</p>
<h5 id="单键合并"><a href="#单键合并" class="headerlink" title="单键合并"></a>单键合并</h5><p>单键合并用 merge 函数，语法如下：</p>
<pre><code>pd.merge( df1, df2, how=s, on=c )
</code></pre>
<p>c 是 df1 和 df2 共有的一栏，合并方式 (how&#x3D;s) 有四种：</p>
<ol>
<li>左连接 (left join)：合并之后显示 df1 的所有行</li>
<li>右连接 (right join)：合并之后显示 df2 的所有行</li>
<li>外连接 (outer join)：合并 df1 和 df2 共有的所有行</li>
<li>内连接 (inner join)：合并所有行 (默认情况)</li>
</ol>
<p>首先创建两个 DataFrame：</p>
<ul>
<li>df_price：4 天的价格 (2019-01-01 到 2019-01-04)</li>
<li>df_volume：5 天的交易量  (2019-01-02 到 2019-01-06)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_price = pd.DataFrame( &#123;&#x27;Date&#x27;: pd.date_range(&#x27;2019-1-1&#x27;, periods=4),</span><br><span class="line">                          &#x27;Adj Close&#x27;: [24.42, 25.00, 25.25, 25.64]&#125;)</span><br><span class="line">df_price</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/aMOHla.jpg" alt="aMOHla"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_volume = pd.DataFrame( &#123;&#x27;Date&#x27;: pd.date_range(&#x27;2019-1-2&#x27;, periods=5), &#x27;Volume&#x27; : [56081400, 99455500, 83028700, 100234000, 73829000]&#125;)</span><br><span class="line">df_volume</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ZTIGoE.jpg" alt="ZTIGoE"></p>
<p>接下来用 df_price  和 df_volume 展示四种合并。</p>
<h6 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;left&#39; )
</code></pre>
<p>按 df_price 里 Date 栏里的值来合并数据</p>
<ul>
<li>df_volume 里 Date 栏里没有 2019-01-01，因此 Volume 为 NaN</li>
<li>df_volume 里 Date 栏里的 2019-01-05 和 2019-01-06 不在 df_price 里 Date 栏，因此丢弃</li>
</ul>
<h6 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;right&#39; )
</code></pre>
<p><img src="http://img.9lake.com/uPic/fqTCgr.jpg" alt="fqTCgr"></p>
<p>按 df_volume 里 Date 栏里的值来合并数据</p>
<ul>
<li>df_price 里 Date 栏里没有 2019-01-05 和 2019-01-06，因此 Adj Close 为 NaN</li>
<li>df_price 里 Date 栏里的 2019-01-01 不在 df_volume 里 Date 栏，因此丢弃</li>
</ul>
<h6 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;outer&#39; )
</code></pre>
<p><img src="http://img.9lake.com/uPic/WaxZZp.jpg" alt="WaxZZp"></p>
<p>按 df_price 和 df_volume 里 Date 栏里的<strong>所有值</strong>来合并数据</p>
<ul>
<li>df_price 里 Date 栏里没有 2019-01-05 和 2019-01-06，因此 Adj Close 为 NaN</li>
<li>df_volume 里 Date 栏里没有 2019-01-01，因此 Volume 为 NaN</li>
</ul>
<h6 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;inner&#39; )
</code></pre>
<p><img src="http://img.9lake.com/uPic/IYKcK4.jpg" alt="IYKcK4"></p>
<p>按 df_price 和 df_volume 里 Date 栏里的<strong>共有值</strong>来合并数据</p>
<ul>
<li>df_price 里 Date 栏里的 2019-01-01 不在 df_volume 里 Date 栏，因此丢弃</li>
<li>df_volume 里 Date 栏里的 2019-01-05 和 2019-01-06 不在 df_price 里 Date 栏，因此丢弃</li>
</ul>
<h5 id="多键合并"><a href="#多键合并" class="headerlink" title="多键合并"></a>多键合并</h5><p>多键合并用的语法和单键合并一样，只不过 on&#x3D;c 中的 c 是多栏。</p>
<pre><code>pd.merge( df1, df2, how=s, on=c )
</code></pre>
<p>首先创建两个 DataFrame：</p>
<ul>
<li>portfolio1：3 比产品 FX Option, FX Swap 和 IR Option 的数量</li>
<li>portfolio2：4 比产品 FX Option (重复名称), FX Swap 和 IR Swap 的数量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">porfolio1 = pd.DataFrame(&#123;&#x27;Asset&#x27;: [&#x27;FX&#x27;, &#x27;FX&#x27;, &#x27;IR&#x27;], </span><br><span class="line">                          &#x27;Instrument&#x27;: [&#x27;Option&#x27;, &#x27;Swap&#x27;, &#x27;Option&#x27;], </span><br><span class="line">                          &#x27;Number&#x27;: [1, 2, 3]&#125;)</span><br><span class="line">porfolio1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/TfUZyD.jpg" alt="TfUZyD"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">porfolio2 = pd.DataFrame(&#123;&#x27;Asset&#x27;: [&#x27;FX&#x27;, &#x27;FX&#x27;, &#x27;FX&#x27;, &#x27;IR&#x27;], </span><br><span class="line">                          &#x27;Instrument&#x27;: [&#x27;Option&#x27;, &#x27;Option&#x27;, &#x27;Swap&#x27;, &#x27;Swap&#x27;], </span><br><span class="line">                          &#x27;Number&#x27;: [4, 5, 6, 7]&#125;)</span><br><span class="line">porfolio2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/lSPGUJ.jpg" alt="lSPGUJ"></p>
<p>在 ‘Asset’ 和 ‘Instrument’ 两个键上做外合并。</p>
<p>pd.merge( porfolio1, porfolio2,<br>          on&#x3D;[‘Asset’,’Instrument’],<br>          how&#x3D;’outer’)</p>
<p><img src="http://img.9lake.com/uPic/AEp8yG.jpg" alt="AEp8yG"></p>
<p>df1 和 df2 中两个键都有 FX Option 和 FX Swap，因此可以合并它们中 number 那栏。</p>
<ul>
<li>df1 中有 IR Option 而 df2 中没有，因此 Number_y 栏下的值为 NaN</li>
<li>df2 中有 IR Swap 而 df1 中没有，因此 Number_x 栏下的值为 NaN</li>
</ul>
<p>当 df1 和 df2 有两个相同的列 (Asset 和 Instrument) 时，单单只对一列 (Asset) 做合并产出的 DataFrame 会有另一列 (Instrument) 重复的名称。这时 merge 函数给重复的名称加个后缀 _x, _y 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge( porfolio1, porfolio2,  on=&#x27;Asset&#x27; )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Z9rp6r.jpg" alt="Z9rp6r"></p>
<p>当没设定 merge 函数里参数 how 时，默认为 inner (内合并)。在 Asset 列下，df1 有 2 个 FX 和 1 个 IR，df2 有 3 个 FX 和 1 个 IR，内合并完有 8 行 (2×3+1×1)。</p>
<p>如果觉得后缀 _x, _y 没有什么具体含义时，可以设定 suffixes 来改后缀。比如 df1 和 df2 存储的是 portoflio1 和 portfolio2 的产品信息，那么将后缀该成 ‘1’ 和 ‘2’ 更贴切。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.merge( porfolio1, porfolio2,</span><br><span class="line">          on=&#x27;Asset&#x27;, </span><br><span class="line">          suffixes=(&#x27;1&#x27;,&#x27;2&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/i6WnhT.jpg" alt="i6WnhT"></p>
<h4 id="4-2-连接"><a href="#4-2-连接" class="headerlink" title="4.2 连接"></a>4.2 连接</h4><p>Numpy 数组可相互连接，用 np.concat；同理，Series 也可相互连接，DataFrame 也可相互连接，用 pd.concat。</p>
<h5 id="连接-Series"><a href="#连接-Series" class="headerlink" title="连接 Series"></a>连接 Series</h5><p>在 concat 函数也可设定参数 axis，</p>
<ul>
<li>axis &#x3D; 0 (默认)，沿着轴 0 (行) 连接，得到一个更长的 Series</li>
<li>axis &#x3D; 1，沿着轴 1 (列) 连接，得到一个 DataFrame</li>
</ul>
<p>被连接的 Series 它们的 index 可以重复 (overlapping)，也可以不同。</p>
<h6 id="overlapping-index"><a href="#overlapping-index" class="headerlink" title="overlapping index"></a>overlapping index</h6><p>先定义三个 Series，它们的 index 各不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([0, 1], index=[&#x27;a&#x27;, &#x27;b&#x27;])</span><br><span class="line">s2 = pd.Series([2, 3, 4], index=[&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])</span><br><span class="line">s3 = pd.Series([5, 6], index=[&#x27;f&#x27;, &#x27;g&#x27;])</span><br></pre></td></tr></table></figure>

<p>沿着「轴 0」连接得到一个更长的 Series。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line">a 0</span><br><span class="line">b 1</span><br><span class="line">c 2</span><br><span class="line">d 3</span><br><span class="line">e 4</span><br><span class="line">f 5</span><br><span class="line">g 6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>沿着「轴 1」连接得到一个 DataFrame。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s2, s3], axis=1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/nQyzJR.jpg" alt="nQyzJR"></p>
<h6 id="non-overlapping-index"><a href="#non-overlapping-index" class="headerlink" title="non-overlapping index"></a>non-overlapping index</h6><p>将 s1 和 s3 沿「轴 0」连接来创建 s4，这样 s4 和 s1 的 index 是有重复的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">s4</span><br><span class="line">a 0</span><br><span class="line">b 1</span><br><span class="line">f 5</span><br><span class="line">g 6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>将 s1 和 s4 沿「轴 1」内连接 (即只连接它们共有 index 对应的值)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s4], axis=1, join=&#x27;inner&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/RCvI9E.jpg" alt="RCvI9E"></p>
<h6 id="hierarchical-index"><a href="#hierarchical-index" class="headerlink" title="hierarchical index"></a>hierarchical index</h6><p>最后还可以将 n 个 Series 沿「轴 0」连接起来，再赋予 3 个 keys 创建多层 Series。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat( [s1, s1, s3], keys=[&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">one a 0</span><br><span class="line">    b 1</span><br><span class="line">two a 0</span><br><span class="line">    b 1</span><br><span class="line">three f 5</span><br><span class="line">      g 6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h5 id="连接-DataFrame"><a href="#连接-DataFrame" class="headerlink" title="连接 DataFrame"></a>连接 DataFrame</h5><p>连接 DataFrame 的逻辑和连接 Series 的一模一样。</p>
<h6 id="沿着行连接-axis-x3D-0"><a href="#沿着行连接-axis-x3D-0" class="headerlink" title="沿着行连接 (axis &#x3D; 0)"></a>沿着行连接 (axis &#x3D; 0)</h6><p>先创建两个 DataFrame，df1 和 df2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame( np.arange(12).reshape(3,4), </span><br><span class="line">                    columns=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/zRAv7a.jpg" alt="zRAv7a"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame( np.arange(6).reshape(2,3),</span><br><span class="line">                    columns=[&#x27;b&#x27;,&#x27;d&#x27;,&#x27;a&#x27;])</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/h0DiGw.jpg" alt="h0DiGw"></p>
<p>沿着行连接分两步</p>
<ul>
<li>先把 df1 和 df2 <strong>列标签</strong>补齐</li>
<li>再把 df1 和 df2 <strong>纵向连</strong>起来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat( [df1, df2] )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/X40WuU.jpg" alt="X40WuU"></p>
<p>得到的 DataFrame 的 index &#x3D; [0,1,2,0,1]，有重复值。如果 index 不包含重要信息 (如上例)，可以将 ignore_index 设置为 True，这样就得到默认的 index 值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat( [df1, df2], ignore_index=True )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/FCIuJv.jpg" alt="FCIuJv"></p>
<h6 id="沿着列连接-axis-x3D-1"><a href="#沿着列连接-axis-x3D-1" class="headerlink" title="沿着列连接 (axis &#x3D; 1)"></a>沿着列连接 (axis &#x3D; 1)</h6><p>先创建两个 DataFrame，df1 和 df2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame( np.arange(6).reshape(3,2), </span><br><span class="line">                    index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">                    columns=[&#x27;one&#x27;,&#x27;two&#x27;] )</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/obPARd.jpg" alt="obPARd"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame( 5 + np.arange(4).reshape(2,2), </span><br><span class="line">                    index=[&#x27;a&#x27;,&#x27;c&#x27;], </span><br><span class="line">                    columns=[&#x27;three&#x27;,&#x27;four&#x27;])</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/1zYJ6K.jpg" alt="1zYJ6K"></p>
<p>沿着列连接分两步</p>
<ul>
<li>先把 df1 和 df2 <strong>行标签</strong>补齐</li>
<li>再把 df1 和 df2 <strong>横向</strong>连起来</li>
</ul>
<p>pd.concat( [df1, df2], axis&#x3D;1 )</p>
<p><img src="http://img.9lake.com/uPic/aA8YzM.jpg" alt="aA8YzM"></p>
<h3 id="数据表的重塑和透视"><a href="#数据表的重塑和透视" class="headerlink" title="数据表的重塑和透视"></a>数据表的重塑和透视</h3><p>重塑 (reshape) 和透视 (pivot) 两个操作只改变数据表的布局 (layout)：</p>
<ul>
<li>重塑用 stack 和 unstack 函数 (互为逆转操作)</li>
<li>透视用 pivot 和 melt 函数 (互为逆转操作)</li>
</ul>
<h4 id="5-1-重塑"><a href="#5-1-重塑" class="headerlink" title="5.1 重塑"></a>5.1 重塑</h4><p>DataFrame 和「多层索引的 Series」其实维度是一样，只是展示形式不同。而重塑就是通过改变数据表里面的「行索引」和「列索引」来改变展示形式。</p>
<ul>
<li>列索引 → 行索引，用 stack 函数</li>
<li>行索引 → 列索引，用 unstack 函数</li>
</ul>
<h5 id="单层-DataFrame"><a href="#单层-DataFrame" class="headerlink" title="单层 DataFrame"></a>单层 DataFrame</h5><p>创建 DataFrame df (1 层行索引，1 层列索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">symbol = [&#x27;JD&#x27;, &#x27;AAPL&#x27;]</span><br><span class="line">data = &#123;&#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;科技&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [25.95, 172.97],</span><br><span class="line">        &#x27;交易量&#x27;: [27113291, 18913154]&#125;</span><br><span class="line">df = pd.DataFrame( data, index=symbol )</span><br><span class="line">df.columns.name = &#x27;特征&#x27;</span><br><span class="line">df.index.name = &#x27;代号&#x27;</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/i8fBGW.jpg" alt="i8fBGW"></p>
<p>从上表中可知：</p>
<ul>
<li>行索引 &#x3D; [JD, AAPL]，名称是代号</li>
<li>列索引 &#x3D; [行业, 价格, 交易量]，名称是特征</li>
</ul>
<h6 id="stack-列索引-→-行索引"><a href="#stack-列索引-→-行索引" class="headerlink" title="stack: 列索引 → 行索引"></a>stack: 列索引 → 行索引</h6><p>列索引 (特征) 变成了行索引，原来的 DataFrame df 变成了两层 Series (第一层索引是代号，第二层索引是特征)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series = df.stack()</span><br><span class="line">c2i_Series</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号 特征</span><br><span class="line">JD   行业 电商</span><br><span class="line">     价格 25.95</span><br><span class="line">     交易量 27113291</span><br><span class="line">AAPL 行业 科技</span><br><span class="line">     价格 172.97</span><br><span class="line">     交易量 18913154</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p><strong>思考：变成行索引的特征和原来行索引的代号之间的层次是怎么决定的？好像特征更靠内一点，代号更靠外一点。</strong></p>
<h6 id="unstack-行索引-→-列索引"><a href="#unstack-行索引-→-列索引" class="headerlink" title="unstack: 行索引 → 列索引"></a>unstack: 行索引 → 列索引</h6><p>行索引 (代号) 变成了列索引，原来的 DataFrame df 也变成了两层 Series (第一层索引是特征，第二层索引是代号)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2c_Series = df.unstack()</span><br><span class="line">i2c_Series</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特征 代号</span><br><span class="line">行业 JD 电商</span><br><span class="line">     AAPL 科技</span><br><span class="line">价格 JD 25.95</span><br><span class="line">     AAPL 172.97</span><br><span class="line">交易量 JD 27113291</span><br><span class="line">       AAPL 18913154</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p><strong>思考：变成列索引的特征和原来列索引的代号之间的层次是怎么决定的？这时好像代号更靠内一点，特征更靠外一点。</strong></p>
<h6 id="规律总结"><a href="#规律总结" class="headerlink" title="规律总结"></a>规律总结</h6><p>对 df 做 stack 和 unstack 都得到了「两层 Series」，但是索引的层次不同，那么在背后的规律是什么？首先我们先来看看两个「两层 Series」的 index 包含哪些信息 (以及 df 的 index 和 columns)。</p>
<p>df.index, df.columns</p>
<p><img src="http://img.9lake.com/uPic/UyHwbm.jpg" alt="UyHwbm"></p>
<p>c2i_Series.index</p>
<p><img src="http://img.9lake.com/uPic/HmNCN1.jpg" alt="HmNCN1"></p>
<p>i2c_Series.index</p>
<p><img src="http://img.9lake.com/uPic/3urHvj.jpg" alt="3urHvj"></p>
<p>定义</p>
<ul>
<li>r &#x3D; [JD, AAPL]，名称是代号</li>
<li>c &#x3D; [行业, 价格, 交易量]，名称是特征</li>
</ul>
<p>那么</p>
<ul>
<li>df 的行索引 &#x3D; r</li>
<li>df 的列索引 &#x3D; c</li>
<li>c2i_Series 的索引 &#x3D; [r, c]</li>
<li>i2c_Series 的索引 &#x3D; [c, r]</li>
</ul>
<p>现在可以总结规律：</p>
<ul>
<li>当用 stack 将 df 变成 c2i_Series 时，df 的列索引 c 加在其行索引 r 后面得到 [r, c] 做为 c2i_Series 的多层索引</li>
<li>当用 unstack 将 df 变成 i2c_Series 时，df 的行索引 r 加在其列索引 c 后面得到 [c, r] 做为 i2c_Series 的多层索引</li>
</ul>
<h6 id="基于层和名称来-unstack"><a href="#基于层和名称来-unstack" class="headerlink" title="基于层和名称来 unstack"></a>基于层和名称来 unstack</h6><p>对于多层索引的 Series，unstack 哪一层有两种方法来确定：</p>
<ul>
<li>基于层 (level-based)</li>
<li>基于名称 (name-based)</li>
</ul>
<p>拿 c2i_Series 举例 (读者也可以尝试 i2c_Series)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号 特征</span><br><span class="line">JD   行业 电商</span><br><span class="line">     价格 25.95</span><br><span class="line">     交易量 27113291</span><br><span class="line">AAPL 行业 科技</span><br><span class="line">     价格 172.97</span><br><span class="line">     交易量 18913154</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<ol>
<li>基于层来 unstack() 时，没有填层数，默认为最后一层。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series.unstack()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/PQCq4S.jpg" alt="PQCq4S"></p>
<p>c2i_Series 的最后一层 (看上面它的 MultiIndex) 就是 [行业, 价格, 交易量]，从行索引转成列索引得到上面的 DataFrame。</p>
<ol start="2">
<li>基于层来 unstack() 时，选择第一层 (参数放 0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series.unstack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/YCIPsG.jpg" alt="YCIPsG"></p>
<p>c2i_Series 的第一层 (看上面它的 MultiIndex) 就是 [JD, AAPL]，从行索引转成列索引得到上面的 DataFrame。</p>
<ol start="3">
<li>基于名称来 unstack</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series.unstack(&#x27;代号&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/SxHDST.jpg" alt="SxHDST"></p>
<p>c2i_Series 的代号层 (看上面它的 MultiIndex) 就是 [JD, AAPL]，从行索引转成列索引得到上面的 DataFrame。</p>
<h5 id="多层-DataFrame"><a href="#多层-DataFrame" class="headerlink" title="多层 DataFrame"></a>多层 DataFrame</h5><p>创建 DataFrame df (2 层行索引，1 层列索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = [ [&#x27;电商&#x27;, 101550, 176.92], </span><br><span class="line">         [&#x27;电商&#x27;, 175336, 25.95], </span><br><span class="line">         [&#x27;金融&#x27;, 60348, 41.79], </span><br><span class="line">         [&#x27;金融&#x27;, 36600, 196.00] ]</span><br><span class="line"></span><br><span class="line">midx = pd.MultiIndex( levels=[[&#x27;中国&#x27;,&#x27;美国&#x27;],</span><br><span class="line">                              [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;GS&#x27;, &#x27;MS&#x27;]], </span><br><span class="line">                      labels=[[0,0,1,1],[0,1,2,3]],</span><br><span class="line">                      names = [&#x27;地区&#x27;, &#x27;代号&#x27;])</span><br><span class="line"></span><br><span class="line">mcol = pd.Index([&#x27;行业&#x27;,&#x27;雇员&#x27;,&#x27;价格&#x27;], name=&#x27;特征&#x27;)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame( data, index=midx, columns=mcol )</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/roWXRN.jpg" alt="roWXRN"></p>
<p>从上表中可知：</p>
<ul>
<li>行索引第一层 &#x3D; r1 &#x3D; [中国, 美国]，名称是地区</li>
<li>行索引第二层 &#x3D; r2 &#x3D; [BABA, JD, GS, MS]，名称是代号</li>
<li>列索引 &#x3D; c &#x3D; [行业, 雇员, 价格]，名称是特征</li>
</ul>
<p>查看 df 的 index 和 columns 的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.index, df.columns</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WN2BuG.jpg" alt="WN2BuG"></p>
<p>那么</p>
<ul>
<li>df 的行索引 &#x3D; [r1, r2]</li>
<li>df 的列索引 &#x3D; c</li>
</ul>
<ol>
<li>基于层来 unstack() 时，选择第一层 (参数放 0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/LlxFB8.jpg" alt="LlxFB8"></p>
<p>df 被 unstack(0) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r2</li>
<li>列索引 &#x3D; [c, r1]</li>
</ul>
<p>重塑后的 DataFrame 这时行索引只有一层 (代号)，而列索引有两层，第一层是特征，第二层是地区。</p>
<ol start="2">
<li>基于层来 unstack() 时，选择第二层 (参数放 1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/fgHf8i.jpg" alt="fgHf8i"></p>
<p>df 被 unstack(1) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>重塑后的 DataFrame 这时行索引只有一层 (地区)，而列索引有两层，第一层是地区，第二层是代号。</p>
<ol start="3">
<li>基于层先 unstack(0) 再 stack(0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(0).stack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/1oQx1g.jpg" alt="1oQx1g"></p>
<p>df 被 unstack(0) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r2</li>
<li>列索引 &#x3D; [c, r1]</li>
</ul>
<p>再被 stack(0) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r2, c]</li>
<li>列索引 &#x3D; r1</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是代号，第二层是特征，而列索引只有一层 (地区)。</p>
<ol start="4">
<li>基于层先 unstack(0) 再 stack(1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(0).stack(1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/oy37su.jpg" alt="oy37su"></p>
<p>df 被 unstack(0) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r2</li>
<li>列索引 &#x3D; [c, r1]</li>
</ul>
<p>再被 stack(1) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r2, r1]</li>
<li>列索引 &#x3D; c</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是代号，第二层是地区，而列索引只有一层 (特征)。</p>
<ol start="5">
<li>基于层先 unstack(1) 再 stack(0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(1).stack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/IO6u4p.jpg" alt="IO6u4p"></p>
<p>df 被 unstack(1) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>再被 stack(0) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r1, c]</li>
<li>列索引 &#x3D; r2</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是地区，第二层是特征，而列索引只有一层 (代号)。</p>
<ol start="6">
<li>基于层先 unstack(1) 再 stack(1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(1).stack(1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/R0cl6M.jpg" alt="R0cl6M"></p>
<p>df 被 unstack(1) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>再被 stack(1) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r1, r2]</li>
<li>列索引 &#x3D; c</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是地区，第二层是特征，而列索引只有一层 (代号)。还原成原来的 df 了。</p>
<ol start="7">
<li>基于层被 stack()，没有填层数，默认为最后一层。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.stack()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">地区 代号 特征</span><br><span class="line">中国 BABA 行业 电商</span><br><span class="line">          雇员 101550</span><br><span class="line">          价格 176.92</span><br><span class="line">     JD 行业 电商</span><br><span class="line">        雇员 175336</span><br><span class="line">...</span><br><span class="line">美国 GS 雇员 60348</span><br><span class="line">        价格 41.79</span><br><span class="line">     MS 行业 金融</span><br><span class="line">        雇员 36600</span><br><span class="line">        价格 196</span><br><span class="line">Length: 12, dtype: object</span><br></pre></td></tr></table></figure>

<p>df 被 stack() 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r1, r2, c]</li>
<li>列索引 &#x3D; []</li>
</ul>
<p>重塑后的 Series 只有行索引，有三层，第一层是地区，第二层是代号，第三层是特征。</p>
<ol start="8">
<li>基于层被 unstack() 两次，没有填层数，默认为最后一层。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack().unstack()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">特征 代号 地区</span><br><span class="line">行业 BABA 中国 电商</span><br><span class="line">          美国 NaN</span><br><span class="line">     JD 中国 电商</span><br><span class="line">        美国 NaN</span><br><span class="line">     GS 中国 NaN</span><br><span class="line">...</span><br><span class="line">价格 JD 美国 NaN</span><br><span class="line">     GS 中国 NaN</span><br><span class="line">        美国 41.79</span><br><span class="line">     MS 中国 NaN</span><br><span class="line">        美国 196</span><br><span class="line">Length: 24, dtype: object</span><br></pre></td></tr></table></figure>

<p>df 被第一次 unstack() 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>df 被第二次 unstack() 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; []</li>
<li>列索引 &#x3D; [c, r2, r1]</li>
</ul>
<p>重塑后的 Series 只有列索引 (实际上是个转置的 Series)，有三层，第一层是特征，第二层是代号，第三层是地区。</p>
<h4 id="5-2-透视"><a href="#5-2-透视" class="headerlink" title="5.2 透视"></a>5.2 透视</h4><p>数据源表通常只包含行和列，那么经常有重复值出现在各列下，因而导致源表不能传递有价值的信息。这时可用「透视」方法调整源表的布局用作更清晰的展示。</p>
<p>#####知识点</p>
<pre><code>本节「透视」得到的数据表和 Excel 里面的透视表 (pivot table) 是一样的。透视表是用来汇总其它表的数据：

1. 首先把源表分组，将不同值当做行 (row)、列 (column) 和值 (value)
1. 然后对各组内数据做汇总操作如排序、平均、累加、计数等

这种动态将·「源表」得到想要「终表」的旋转 (pivoting) 过程，使透视表得以命名。
</code></pre>
<p>在 Pandas 里透视的方法有两种：</p>
<ul>
<li>用 pivot 函数将「一张长表」变「多张宽表」，</li>
<li>用 melt 函数将「多张宽表」变「一张长表」，</li>
</ul>
<p>本节使用的数据描述如下：</p>
<ul>
<li>5 只股票：AAPL, JD, BABA, FB, GS</li>
<li>4 个交易日：从 2019-02-21 到 2019-02-26</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(&#x27;Stock.csv&#x27;, parse_dates=[0], dayfirst=True)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/e6e52i.jpg" alt="e6e52i"></p>
<p>从上表看出有 20 行 (5 × 4) 和 8 列，在 Date 和 Symbol 那两列下就有重复值，4 个日期和 5 个股票在 20 行中分别出现了 5 次和 4 次。</p>
<p>从长到宽 (pivot)</p>
<p>当我们做数据分析时，只关注不同股票在不同日期下的 Adj Close，那么可用 pivot 函数可将原始 data「透视」成一个新的 DataFrame，起名 close_price。在 pivot 函数中</p>
<ul>
<li>将 index 设置成 ‘Date’</li>
<li>将 columns 设置成 ‘Symbol’</li>
<li>将 values 设置 ‘Adj Close’</li>
</ul>
<p>close_price 实际上把 data[‘Date’] 和 data[‘Symbol’] 的唯一值当成支点(pivot 就是支点的意思) 创建一个 DataFrame，其中</p>
<ul>
<li>行标签 &#x3D; 2019-02-21, 2019-02-22, 2019-02-25, 2019-02-26</li>
<li>列标签 &#x3D; AAPL, JD, BABA, FB, GS</li>
</ul>
<p>在把 data[‘Adj Close’] 的值放在以如上的行标签和列标签创建的 close_price 来展示。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">close_price = data.pivot( index=&#x27;Date&#x27;,</span><br><span class="line">                          columns=&#x27;Symbol&#x27;,</span><br><span class="line">                          values=&#x27;Adj Close&#x27; )</span><br><span class="line">close_price</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/DukrkI.jpg" alt="DukrkI"></p>
<p>如果觉得 Adj Close 不够，还想加个 Volume 看看，那么就把 values 设置成 [‘Adj Close’, ‘Volume’]。这时支点还是 data[‘Date’] 和 data[‘Symbol’]，但是要透视的值增加到 data[[‘Adj Close’, ‘Volume’]] 了。pivot 函数返回的是两个透视表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.pivot( index=&#x27;Date&#x27;,</span><br><span class="line">            columns=&#x27;Symbol&#x27;,</span><br><span class="line">            values=[&#x27;Adj Close&#x27;,&#x27;Volume&#x27;] )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/tIMwmQ.jpg" alt="tIMwmQ"></p>
<p>如果不设置 values 参数，那么 pivot 函数返回的是六个透视表。(源表 data 有八列，两列当了支点，剩下六列用来透视)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_pivot = data.pivot( index=&#x27;Date&#x27;, </span><br><span class="line">                        columns=&#x27;Symbol&#x27; )</span><br><span class="line">all_pivot</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/FHXTWu.jpg" alt="FHXTWu"></p>
<p>再继续观察下，all_pivot 实际上是个多层 DataFrame (有多层 columns)。假设我们要获取 2019-02-25 和 2019-02-26 两天的 BABA 和 FB 的开盘价，用以下「多层索引和切片」的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_pivot[&#x27;Open&#x27;].iloc[2:,1:3]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Iqzwtb.jpg" alt="Iqzwtb"></p>
<p><strong>从宽到长 (melt)</strong></p>
<p>pivot 逆反操作是 melt。</p>
<ul>
<li>前者将「一张长表」变成「多张宽表」</li>
<li>后者将「多张宽表」变成「一张长表」</li>
</ul>
<p>具体来说，函数 melt 实际是将「源表」转化成 id-variable 类型的 DataFrame，下例将</p>
<ul>
<li>Date 和 Symbol 列当成 id</li>
<li>其他列 Open, High, Low, Close, Adj Close 和 Volume 当成 variable，而它们对应的值当成 value</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">melted_data = pd.melt( data, id_vars=[&#x27;Date&#x27;,&#x27;Symbol&#x27;] )</span><br><span class="line">melted_data.head(5).append(melted_data.tail(5))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/lc4WCf.jpg" alt="lc4WCf"></p>
<p>新生成的 DataFrame 有 120 行 (4 × 5 × 6)</p>
<ul>
<li>4 &#x3D; data[‘Date’] 有 4 个日期</li>
<li>5 &#x3D; data[‘Symbol’] 有 5 只股票</li>
<li>6 &#x3D; Open, High, Low, Close, Adj Close 和 Volume 这 6 个变量</li>
</ul>
<p>在新表 melted_data 中</p>
<ul>
<li><p>在参数 id_vars 设置的 Date 和 Symbol 还保持为 columns</p>
</li>
<li><p>此外还多出两个 columns，一个叫 variable，一个叫 value</p>
<ul>
<li>variable 列下的值为 Open, High, Low, Close, Adj Close 和 Volume</li>
<li>value 列下的值为前者在「源表 data」中的值</li>
</ul>
</li>
</ul>
<p>函数 melt 可以生成一张含有多个 id 的长表，然后可在 id 上筛选出我们想要的信息，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">melted_data[ lambda x: (x.Date==&#x27;25/02/2019&#x27;) </span><br><span class="line">                     &amp; ((x.Symbol==&#x27;BABA&#x27;)|(x.Symbol==&#x27;FB&#x27;)) ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/NIgXqR.jpg" alt="NIgXqR"></p>
<p>在 melted_data 上使用<strong>调用函数</strong> (callable function) 做索引，我们得到了在 2019-02-25 那天 BABA 和 FB 的信息。</p>
<h3 id="数据表的分组和整合"><a href="#数据表的分组和整合" class="headerlink" title="数据表的分组和整合"></a>数据表的分组和整合</h3><p>DataFrame 中的数据可以根据某些规则分组，然后在每组的数据上计算出不同统计量。这种操作称之为 split-apply-combine</p>
<h4 id="6-1-数据准备"><a href="#6-1-数据准备" class="headerlink" title="6.1 数据准备"></a>6.1 数据准备</h4><p>本节使用的数据描述如下：</p>
<ul>
<li>5 只股票：AAPL, JD, BABA, FB, GS</li>
<li>1 年时期：从 2018-02-26 到 2019-02-26</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(&#x27;1Y Stock Data.csv&#x27;, parse_dates=[0], dayfirst=True)</span><br><span class="line">data.head(3).append(data.tail(3))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/9qq3Oh.jpg" alt="9qq3Oh"></p>
<p>我们目前只对 Adj Close 感兴趣，而且想知道在哪一年份或哪一月份每支股票的 Adj Close 是多少。因此我们需要做两件事：</p>
<p>只保留 ‘Date’, ‘Symbol’ 和 ‘Adj Close‘<br>从 ‘Date’ 中获取 ‘Year’ 和 ‘Month’ 的信息并插入表中</p>
<p>将处理过后的数据存在 data1 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data1 = data[[&#x27;Date&#x27;, &#x27;Symbol&#x27;, &#x27;Adj Close&#x27;]]</span><br><span class="line">data1.insert( 1, &#x27;Year&#x27;, pd.DatetimeIndex(data1[&#x27;Date&#x27;]).year )</span><br><span class="line">data1.insert( 2, &#x27;Month&#x27;, pd.DatetimeIndex(data1[&#x27;Date&#x27;]).month )</span><br><span class="line">data1.head(3).append(data1.tail(3))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/LQeh3U.jpg" alt="LQeh3U"></p>
<h4 id="6-2-分组-grouping"><a href="#6-2-分组-grouping" class="headerlink" title="6.2 分组 (grouping)"></a>6.2 分组 (grouping)</h4><p>用某一特定标签 (label) 将数据 (data) 分组的语法如下：</p>
<pre><code>data.groupBy( label )
</code></pre>
<h5 id="单标签分组"><a href="#单标签分组" class="headerlink" title="单标签分组"></a>单标签分组</h5><p>首先我们按 Symbol 来分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped = data1.groupby(&#x27;Symbol&#x27;)</span><br><span class="line">grouped</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pandas.core.groupby.groupby.DataFrameGroupBy</span><br><span class="line">object at 0x7fbbc7248d68&gt;</span><br></pre></td></tr></table></figure>

<p>又要提起那句说了无数遍的话「万物皆对象」了。这个 grouped 也不例外，当你对如果使用某个对象感到迷茫时，用 dir() 来查看它的「属性」和「内置方法」。以下几个属性和方法是我们感兴趣的：</p>
<ul>
<li>ngroups: 组的个数 (int)</li>
<li>size(): 每组元素的个数 (Series)</li>
<li>groups: 每组元素在原 DataFrame 中的索引信息 (dict)</li>
<li>get_groups(label): 标签 label 对应的数据 (DataFrame)</li>
</ul>
<p>下面看看这些属性和方法的产出结果。</p>
<p>数据里有 5 只股票，因此有 5 组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.ngroups</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>一年有 252 个交易日，因此每只股票含 252 条信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.size()</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol</span><br><span class="line">AAPL 252</span><br><span class="line">BABA 252</span><br><span class="line">FB 252</span><br><span class="line">GS 252</span><br><span class="line">JD 252</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>苹果股票 (AAPL) 的索引从 0 到 251，…，一直到高盛股票 (GS) 的索引从 1008 到 1259。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.groups</span><br></pre></td></tr></table></figure>


<p><img src="http://img.9lake.com/uPic/COuAEk.jpg" alt="COuAEk"></p>
<p>查查 ‘GS’ 组里的数据的前五行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.get_group(&#x27;GS&#x27;).head()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/l2eL53.jpg" alt="l2eL53"></p>
<p>接下来定义个 print_groups 函数便于打印组的名字和前五行信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def print_groups( group_obj ):</span><br><span class="line">    for name, group in group_obj:</span><br><span class="line">        print( name )</span><br><span class="line">        print( group.head() )</span><br></pre></td></tr></table></figure>



<p>用这个函数来调用 grouped (上面用 groupBy 得到的对象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_groups( grouped )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/QGeNbl.jpg" alt="QGeNbl"></p>
<p>这个 print_groups 函数在下面也多次被用到。</p>
<h5 id="多标签分组"><a href="#多标签分组" class="headerlink" title="多标签分组"></a>多标签分组</h5><p>groupBy 函数除了支持单标签分组，也支持多标签分组 (将标签放入一个列表中)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped2 = data1.groupby([&#x27;Symbol&#x27;, &#x27;Year&#x27;, &#x27;Month&#x27;])</span><br><span class="line">print_groups( grouped2 )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/PYPFat.jpg" alt="PYPFat"></p>
<p><img src="http://img.9lake.com/uPic/MBSKV8.jpg" alt="MBSKV8"></p>
<p>不难看出在每组左上方，有一个 (Symbol, Year, Month) 元组型的标识：</p>
<ul>
<li>第一组：(‘AAPL’, 2018, 2)</li>
<li>最后一组：(‘JD’, 2019, 2)</li>
</ul>
<p>还记得的重设索引 (set_index) 的操作么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data2 = data1.set_index([&#x27;Symbol&#x27;, &#x27;Year&#x27;, &#x27;Month&#x27;])</span><br><span class="line">data2.head().append(data2.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/c9Kb1k.jpg" alt="c9Kb1k"></p>
<p>对 data1 重设索引之后，产出是一个有 multi-index 的 DataFrame，记做 data2。由于有多层索引，这时我们根据索引的 level 来分组，下面 level &#x3D; 1 就是对第一层 (Year) 进行分组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped3 = data2.groupby(level=1)</span><br><span class="line">print_groups( grouped3 )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Kn1cWM.jpg" alt="Kn1cWM"></p>
<p>注意每组<strong>左上方</strong>的标识是  Year。</p>
<p>多层索引中的任意个数的索引也可以用来分组，下面 level &#x3D; [0,2] 就是对第零层 (Symbol) 和第二层 (Month) 进行分组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped4 = data2.groupby(level=[0, 2])</span><br><span class="line">print_groups( grouped4 )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WCmBXk.jpg" alt="WCmBXk"></p>
<p><img src="http://img.9lake.com/uPic/fcQxXH.jpg" alt="fcQxXH"></p>
<p>注意每组左上方的标识是 (Symbol, Month)。</p>
<h4 id="6-3-整合-aggregating"><a href="#6-3-整合-aggregating" class="headerlink" title="6.3 整合 (aggregating)"></a>6.3 整合 (aggregating)</h4><p>做完分组之后 so what？当然是在每组做点数据分析再整合啦。</p>
<p>一个最简单的例子就是上节提到的 size() 函数，用 grouped 对象 (上面根据 Symbol 分组得到的) 来举例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.size()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol</span><br><span class="line">AAPL 252</span><br><span class="line">BABA 252</span><br><span class="line">FB 252</span><br><span class="line">GS 252</span><br><span class="line">JD 252</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>一个更实际的例子是用 mean() 函数计算每个 Symbol 下 1 年时期的股价均值。在获取任意信息就用 DataFrame 的索引或切片那一套方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.mean()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/TFJohc.jpg" alt="TFJohc"></p>
<p>除了上述方法，整合还可以用内置函数 aggregate() 或 agg() 作用到「组对象」上。用 grouped4 对象 (上面根据 Symbol, Year, Month 分组得到的) 来举例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = grouped4.agg( np.mean )</span><br><span class="line">result.head().append(result.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/4ynBBL.jpg" alt="4ynBBL"></p>
<p>函数 agg() 其实是一个高阶函数里面的参数可以是另外一个函数，比如上例的 np.mean。上面代码对每只股票在每年每个月上求均值。</p>
<p>那么参数可以是另外一组函数么？可以的！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = grouped4.agg( [np.mean, np.std] )</span><br><span class="line">result.head().append(result.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/weahpH.jpg" alt="weahpH"></p>
<p>将 np.mean 和 np.std 放进列表中，当成是高阶函数 agg() 的参数。上面代码对每只股票在每年每个月上求均值和标准差。</p>
<p>既然 agg() 是高阶函数，参数当然也可以是匿名函数 (lambda 函数)，下面我们定义一个对 grouped 里面每个标签下求最大值和最小值，再求差。注意 lambda 函数里面的 x 就是 grouped。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = grouped.agg( lambda x: np.max(x)-np.min(x) )</span><br><span class="line">result.head().append(result.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/zd1W8V.jpg" alt="zd1W8V"></p>
<p>上面代码对每只股票在 Date, Year, Month 和 Adj Close 上求「最大值」和「最小值」的差。真正有价值的信息在 Adj Close 那一栏，但我们来验证一下其他几栏。</p>
<ul>
<li>Date: 365 days，合理，一年数据</li>
<li>Year: 1，合理，2019 年和 2018 年</li>
<li>Month: 11，合理，12 月和 1 月。</li>
</ul>
<h4 id="6-4-split-apply-combine"><a href="#6-4-split-apply-combine" class="headerlink" title="6.4 split-apply-combine"></a>6.4 split-apply-combine</h4><p>前几节做的事情的实质就是一个 split-apply-combine 的过程，如下图所示：</p>
<p><img src="http://img.9lake.com/uPic/1teLhF.jpg" alt="1teLhF"></p>
<p>该 split-apply-combine 过程有三步：</p>
<ol>
<li>根据 key 来 split 成 n 组</li>
<li>将函数 apply 到每个组</li>
<li>把 n 组的结果 combine 起来</li>
</ol>
<p>在看具体例子之前，我们先定一个 top 函数，返回 DataFrame 某一栏中 n 个最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def top( df, n=5, column=&#x27;Volume&#x27; ):</span><br><span class="line">    return df.sort_values(by=column)[-n:]</span><br></pre></td></tr></table></figure>

<p>将 top 函数用到最原始的数据 (从 csv 中读取出来的) 上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top( data )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/urWYaU.jpg" alt="urWYaU"></p>
<p>从上表可看出，在 Volume 栏取 5 个最大值。</p>
<h5 id="Apply-函数"><a href="#Apply-函数" class="headerlink" title="Apply 函数"></a>Apply 函数</h5><p>在 split-apply-combine 过程中，apply 是核心。Python 本身有高阶函数 apply() 来实现它，既然是高阶函数，参数可以是另外的函数了，比如刚定义好的 top()。</p>
<p>将 top() 函数 apply 到按 Symbol 分的每个组上，按每个 Symbol 打印出来了 Volume 栏下的 5 个最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.groupby(&#x27;Symbol&#x27;).apply(top)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/tM0EIW.jpg" alt="tM0EIW"></p>
<p>上面在使用 top() 时，对于 n 和 column 我们都只用的默认值 5 和 ‘Volumn’。如果用自己设定的值 n &#x3D; 1, column &#x3D; ‘Adj Close’，写法如下(下面使用在元数据上插入 Year 和 Month 的数据)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data1.groupby([&#x27;Symbol&#x27;,&#x27;Year&#x27;]).apply(top, n=1, column=&#x27;Adj Close&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/J6cyF9.jpg" alt="J6cyF9"></p>
<p>按每个 Symbol 和 Year 打印出来了 Adj Close 栏下的最大值。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Pandas 里面的数据结构是多维数据表，细化为一维的 Series，二维的 DataFrame，三维的 Panel。</p>
<pre><code>多维数据表 = 多维数组 + 描述
</code></pre>
<p>其中</p>
<ul>
<li>Series &#x3D; 1darray + index</li>
<li>DataFrame &#x3D; 2darray + index + columns</li>
<li>Panel &#x3D; 3darray + index + columns + item</li>
</ul>
<p>pd 多维数据表和 np 多维数组之间的类比关系如下图所示。</p>
<p><img src="http://img.9lake.com/uPic/Qnzeq3.jpg" alt="Qnzeq3"></p>
<p><strong>【创建数据表】</strong>创建 Series, DataFrame, Panel 用下面语句</p>
<ul>
<li>pd.Series(x, index&#x3D;idx)</li>
<li>pd.DataFrame(x, index&#x3D;idx, columns&#x3D;col)</li>
<li>pd.Panel(x, item&#x3D;itm, major_axis&#x3D;n1, minor_axis&#x3D;n2)</li>
</ul>
<p>DataFrame 由多个 Series 组成，Panel 有多个 DataFrame 组成。Series 非常类似于一维的 DataFrame，Panel 未来会被废掉，因此学 Pandas 把注意力放在 DataFrame 上即可。</p>
<p><strong>【索引和切片数据表】</strong>在索引或切片 DataFrame，有很多种方法。最好记的而不易出错的是用基于位置的 at 和 loc，和基于标签的 iat 和 iloc，具体来说，索引用 at 和 iat，切片用 loc 和 iloc。带 i 的基于位置，不带 i 的基于标签。</p>
<p>用 MultiIndex 可以创建多层索引的对象，获取 DataFrame df 的信息可用</p>
<ul>
<li>df.loc[1st].loc[2nd]</li>
<li>df.loc[1st].iloc[2nd]</li>
<li>df.iloc[1st].loc[2nd]</li>
<li>df.iloc[1st].iloc[2nd]</li>
</ul>
<p>要调换 level 可用</p>
<ul>
<li>df.index.swaplevel(0,1)</li>
<li>df.columns.swaplevel(0,1)</li>
</ul>
<p>要设置和重设 index 可用</p>
<ul>
<li>df.set_index( columns )</li>
<li>df.reset_index</li>
</ul>
<p><strong>【合并数据表】</strong> 用 merge 函数按数据表的共有列进行左&#x2F;右&#x2F;内&#x2F;外合并。</p>
<p><img src="http://img.9lake.com/uPic/vlLEzQ.jpg" alt="vlLEzQ"></p>
<p>【连接数据表】用 concat 函数对 Series 和 DataFrame 沿着不同轴连接。</p>
<p>【重塑数据表】用 stack 函数将「列索引」变成「行索引」，用 unstack 函数将「行索引」变成「列索引」。它们只是改变数据表的布局和展示方式而已。</p>
<p><img src="http://img.9lake.com/uPic/eDp66D.jpg" alt="eDp66D"></p>
<p><img src="http://img.9lake.com/uPic/ojKysH.jpg" alt="ojKysH"></p>
<p><img src="http://img.9lake.com/uPic/JlrQJW.jpg" alt="JlrQJW"></p>
<p>【透视数据表】用 pivot 函数将「一张长表」变成「多张宽表」，用 melt 函数将「多张宽表」变成「一张长表」。它们只是改变数据表的布局和展示方式而已。</p>
<p><img src="http://img.9lake.com/uPic/k5UEPK.jpg" alt="k5UEPK"></p>
<p><img src="http://img.9lake.com/uPic/1MEZmp.jpg" alt="1MEZmp"></p>
<p>【分组数据表】用 groupBy 函数按不同「列索引」下的值分组。一个「列索引」或多个「列索引」就可以。</p>
<p>【整合数据表】用 agg 函数对每个组做整合而计算统计量。</p>
<p>【split-apply-combine】用 apply 函数做数据分析时美滋滋。</p>
<p><img src="http://img.9lake.com/uPic/fPakDK.jpg" alt="fPakDK"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSklearn/" rel="prev" title="机器学习之Sklearn">
      <i class="fa fa-chevron-left"></i> 机器学习之Sklearn
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/15/%E5%9F%BA%E6%9C%AC%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8BMatplotlib/" rel="next" title="基本可视化之Matplotlib">
      基本可视化之Matplotlib <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.</span> <span class="nav-text">数据表的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.0.1.</span> <span class="nav-text">知识点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%8C%89%E9%83%A8%E5%B0%B1%E7%8F%AD%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">2.1 按部就班法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4Series"><span class="nav-number">1.1.1.</span> <span class="nav-text">一维Series</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">用列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8-numpy-%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">用 numpy 数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E5%AD%97%E5%85%B8"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">用字典</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4-DataFrame"><span class="nav-number">1.1.2.</span> <span class="nav-text">二维 DataFrame</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E5%88%97%E8%A1%A8%E6%88%96-numpy-%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">用列表或 numpy 数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%88%97%E8%A1%A8%E7%9A%84%E5%AD%97%E5%85%B8"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">用对象为列表的字典</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%BB%B4-Panel"><span class="nav-number">1.1.3.</span> <span class="nav-text">三维 Panel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8-numpy-%E6%95%B0%E7%BB%84-1"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">用 numpy 数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%BA-DataFrame-%E7%9A%84%E5%AD%97%E5%85%B8"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">用对象为 DataFrame 的字典</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%AD%A5%E7%99%BB%E5%A4%A9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">一步登天法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%BA%8F%E5%88%97%E5%87%BD%E6%95%B0-wsd"><span class="nav-number">1.2.1.</span> <span class="nav-text">日期序列函数 wsd</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%93%81%E7%A7%8D%E5%8D%95%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">单品种单指标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">知识点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%93%81%E7%A7%8D%E5%A4%9A%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">单品种多指标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%93%81%E7%A7%8D%E5%8D%95%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">多品种单指标</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0-wss"><span class="nav-number">1.2.2.</span> <span class="nav-text">多维数据函数 wss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0-wsq"><span class="nav-number">1.2.3.</span> <span class="nav-text">行情数据函数 wsq</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%92%9F%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0-wsi"><span class="nav-number">1.2.4.</span> <span class="nav-text">分钟序列数据函数 wsi</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E8%BD%BD"><span class="nav-number">1.3.</span> <span class="nav-text">数据表的存载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Excel-%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">Excel 格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#csv-%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">csv 格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87"><span class="nav-number">1.4.</span> <span class="nav-text">数据表的索引和切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E7%B4%A2%E5%BC%95%E5%8D%95%E5%85%83%E7%B4%A0"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 索引单元素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">情况 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">情况 2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%88%87%E7%89%87-columns"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2 切片 columns</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%8D%95%E4%B8%AA-columns"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">切片单个 columns</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1-1"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">情况 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2-1"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">情况 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-3"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">情况 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-4"><span class="nav-number">1.4.2.1.4.</span> <span class="nav-text">情况 4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%A4%9A%E4%B8%AA-columns"><span class="nav-number">1.4.3.</span> <span class="nav-text">切片多个 columns</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1-2"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">情况 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2-2"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">情况 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%85%E5%86%B5-3-1"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">情况 3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%88%87%E7%89%87-index"><span class="nav-number">1.4.4.</span> <span class="nav-text">3.3 切片 index</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%8D%95%E4%B8%AA-index"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">切片单个 index</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1-3"><span class="nav-number">1.4.4.1.1.</span> <span class="nav-text">情况 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2-3"><span class="nav-number">1.4.4.1.2.</span> <span class="nav-text">情况 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-3-2"><span class="nav-number">1.4.4.1.3.</span> <span class="nav-text">情况 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-4-1"><span class="nav-number">1.4.4.1.4.</span> <span class="nav-text">情况 4</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%A4%9A%E4%B8%AA-index"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">切片多个 index</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1-4"><span class="nav-number">1.4.4.2.1.</span> <span class="nav-text">情况 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2-4"><span class="nav-number">1.4.4.2.2.</span> <span class="nav-text">情况 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-3-3"><span class="nav-number">1.4.4.2.3.</span> <span class="nav-text">情况 3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E5%88%87%E7%89%87-index-%E5%92%8C-columns"><span class="nav-number">1.4.5.</span> <span class="nav-text">3.4 切片 index 和 columns</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1-5"><span class="nav-number">1.4.5.0.1.</span> <span class="nav-text">情况 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2-5"><span class="nav-number">1.4.5.0.2.</span> <span class="nav-text">情况 2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-%E9%AB%98%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.6.</span> <span class="nav-text">3.5 高级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">布尔索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">调用函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.7.</span> <span class="nav-text">3.6 多层索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95-Series"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">多层索引 Series</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95-DataFrame"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">多层索引 DataFrame</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E4%BD%8D-level"><span class="nav-number">1.4.7.4.</span> <span class="nav-text">调位 level</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%AE%BE-index"><span class="nav-number">1.4.7.5.</span> <span class="nav-text">重设 index</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6%E5%92%8C%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.5.</span> <span class="nav-text">数据表的合并和连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%90%88%E5%B9%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E9%94%AE%E5%90%88%E5%B9%B6"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">单键合并</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#left-join"><span class="nav-number">1.5.1.1.1.</span> <span class="nav-text">left join</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#right-join"><span class="nav-number">1.5.1.1.2.</span> <span class="nav-text">right join</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#outer-join"><span class="nav-number">1.5.1.1.3.</span> <span class="nav-text">outer join</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#inner-join"><span class="nav-number">1.5.1.1.4.</span> <span class="nav-text">inner join</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%94%AE%E5%90%88%E5%B9%B6"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">多键合并</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2 连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5-Series"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">连接 Series</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#overlapping-index"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">overlapping index</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#non-overlapping-index"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">non-overlapping index</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hierarchical-index"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">hierarchical index</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5-DataFrame"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">连接 DataFrame</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B2%BF%E7%9D%80%E8%A1%8C%E8%BF%9E%E6%8E%A5-axis-x3D-0"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">沿着行连接 (axis &#x3D; 0)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B2%BF%E7%9D%80%E5%88%97%E8%BF%9E%E6%8E%A5-axis-x3D-1"><span class="nav-number">1.5.2.2.2.</span> <span class="nav-text">沿着列连接 (axis &#x3D; 1)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A1%91%E5%92%8C%E9%80%8F%E8%A7%86"><span class="nav-number">1.6.</span> <span class="nav-text">数据表的重塑和透视</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E9%87%8D%E5%A1%91"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1 重塑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%B1%82-DataFrame"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">单层 DataFrame</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#stack-%E5%88%97%E7%B4%A2%E5%BC%95-%E2%86%92-%E8%A1%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.1.1.1.</span> <span class="nav-text">stack: 列索引 → 行索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#unstack-%E8%A1%8C%E7%B4%A2%E5%BC%95-%E2%86%92-%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.1.1.2.</span> <span class="nav-text">unstack: 行索引 → 列索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%84%E5%BE%8B%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.1.1.3.</span> <span class="nav-text">规律总结</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%82%E5%92%8C%E5%90%8D%E7%A7%B0%E6%9D%A5-unstack"><span class="nav-number">1.6.1.1.4.</span> <span class="nav-text">基于层和名称来 unstack</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82-DataFrame"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">多层 DataFrame</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E9%80%8F%E8%A7%86"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2 透视</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%88%86%E7%BB%84%E5%92%8C%E6%95%B4%E5%90%88"><span class="nav-number">1.7.</span> <span class="nav-text">数据表的分组和整合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="nav-number">1.7.1.</span> <span class="nav-text">6.1 数据准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%88%86%E7%BB%84-grouping"><span class="nav-number">1.7.2.</span> <span class="nav-text">6.2 分组 (grouping)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E6%A0%87%E7%AD%BE%E5%88%86%E7%BB%84"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">单标签分组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%BB%84"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">多标签分组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E6%95%B4%E5%90%88-aggregating"><span class="nav-number">1.7.3.</span> <span class="nav-text">6.3 整合 (aggregating)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-split-apply-combine"><span class="nav-number">1.7.4.</span> <span class="nav-text">6.4 split-apply-combine</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Apply-%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">Apply 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="草根之明"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">草根之明</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/justinzm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;justinzm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3907721@qq.com" title="E-Mail → mailto:3907721@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">草根之明</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
