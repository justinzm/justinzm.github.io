<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"justinzm.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="草根之明">
<meta property="og:url" content="https://justinzm.github.io/page/5/index.html">
<meta property="og:site_name" content="草根之明">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="草根之明">
<meta property="article:tag" content="项目管理、产品管理、区块链">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://justinzm.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>草根之明</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">草根之明</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">管理及技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2020/08/25/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%8410%E7%A7%8D%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%AF%B9%E7%AD%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%8410%E7%A7%8D%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%AF%B9%E7%AD%96/" class="post-title-link" itemprop="url">项目管理中常见的10种疑难杂症及解决对策</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 22:26:33" itemprop="dateCreated datePublished" datetime="2020-08-25T22:26:33+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 12:09:34" itemprop="dateModified" datetime="2021-04-24T12:09:34+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">项目管理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-项目工期不断延后"><a href="#1-项目工期不断延后" class="headerlink" title="1.项目工期不断延后"></a>1.项目工期不断延后</h3><h4 id="主要表现"><a href="#主要表现" class="headerlink" title="主要表现"></a>主要表现</h4><p>项目的最后期限总是一延再延，其原因各式各样，其中包括计划不周、意外频发及业务复杂等。</p>
<h4 id="解决对策"><a href="#解决对策" class="headerlink" title="解决对策"></a>解决对策</h4><p>项目经理可以将可交付成果分解开来，要求项目团队每两个星期要完成一部分有价值且可衡量的成果，这样成果会逐渐越积越多。对于风险较高的项目来说，这个时间可以设定得更短一些。对可交付成果进行管理使得项目监管变得更加容易，同时也能在连贯的基础上进行风险管理。</p>
<h3 id="2-项目需求不断变更"><a href="#2-项目需求不断变更" class="headerlink" title="2.项目需求不断变更"></a>2.项目需求不断变更</h3><h4 id="主要表现-1"><a href="#主要表现-1" class="headerlink" title="主要表现"></a>主要表现</h4><p>在项目执行过程中，即使我们尽最大的努力去完成，还是可能会因为一些因素导致项目需求变更。比如原计划考虑不周、上层领导提出新的要求或其他相关方增加、删减或改动需求。</p>
<h4 id="解决对策-1"><a href="#解决对策-1" class="headerlink" title="解决对策"></a>解决对策</h4><p>要求不断发生变化，背后的动机是为了让客户和用户满意。在项目启动之初，即应明确变更流程是如何操作的，何时需要应用这一流程。让相关方了解未来的需求变更将要求项目团队再次发布项目信息。在需求发生改变之初，就应该让相关方了解它将对成本、利益和项目本身造成的影响，让用户或相关方在这些事实的基础上做出决策。</p>
<h3 id="3-项目中的决策摇摆"><a href="#3-项目中的决策摇摆" class="headerlink" title="3.项目中的决策摇摆"></a>3.项目中的决策摇摆</h3><h4 id="主要表现-2"><a href="#主要表现-2" class="headerlink" title="主要表现"></a>主要表现</h4><p>业务决策有始无终、摇摆不定是风雨欲来的征兆。许多项目，不论是小项目还是价值五千万美元的大型项目，都有可能是建立在某个高层的业务愿景之上，而该愿景则是由若干尚未完成的“故事”大纲和业务章程组成的半成品。这样的愿景只能带着项目团队前进一小段，直到你发现由于项目缺乏清晰的目标而必须不断返工为止。</p>
<h4 id="解决对策-2"><a href="#解决对策-2" class="headerlink" title="解决对策"></a>解决对策</h4><p>项目生命周期之初，就该确定以下几项决策：</p>
<p>✤ 谁是企业的所有者，谁决定最终的项目验收条件？<br>✤ 项目的最终产品应该是怎样的？<br>✤ 缺陷率为多少是可以接受的？</p>
<p>最终解决方案的绩效及运作指标有哪些？<br>准则有哪些？哪些是关键？剩下的准则中，优先次序如何？哪些将会被用户所接受？</p>
<h3 id="4-行百里，半九十"><a href="#4-行百里，半九十" class="headerlink" title="4.行百里，半九十"></a>4.行百里，半九十</h3><h4 id="主要表现-3"><a href="#主要表现-3" class="headerlink" title="主要表现"></a>主要表现</h4><p>当某位项目经理第一次听到项目已经完成了90%，肯定会异常兴奋和开心。项目完成到这个程度是不断累积的成果，而且这个成果应该是在定期的进度报告或进度会议上予以汇报的。</p>
<p>然而，进度报告可能会存在若干问题，报告的数据通常都是建立在对项目的不精确评估之上的，或出自项目经理、项目协调员的直觉。项目剩下的10%有多复杂依然是个未知数，而且这个看起来较小的百分比还有可能让人掉以轻心。</p>
<h4 id="解决对策-3"><a href="#解决对策-3" class="headerlink" title="解决对策"></a>解决对策</h4><p>项目倾向于滞留在这个阶段。当项目进度在相应的进度报告期间内停滞不前时，要好好想一想原因。这可能是由于新的项目要求所导致的，也可能是早期的进度汇报不真实的结果。通常情况下，你所看到的下降比率可能并不会很低，因为项目团队出于主观愿望，会对进度报告进行一些修饰。所以，问题可能远比报告上所显示的要严重得多。</p>
<h3 id="5-项目中一切正常的假象"><a href="#5-项目中一切正常的假象" class="headerlink" title="5.项目中一切正常的假象"></a>5.项目中一切正常的假象</h3><h4 id="主要表现-4"><a href="#主要表现-4" class="headerlink" title="主要表现"></a>主要表现</h4><p>所有项目都会时不时碰到这样或那样的阻碍和问题。虽然其中的许多困难很容易被克服，但还是会出现。如果这些困难没有上报，那说明项目团队要么是对项目探究得不够深入，要么是没有就相关信息进行沟通。</p>
<h4 id="解决对策-4"><a href="#解决对策-4" class="headerlink" title="解决对策"></a>解决对策</h4><p>项目经理也许需要仔细研究当前的项目进展和可交付成果，以确保所提出的问题正是要旨所在。如果项目真的进展得非常顺利，那么在到达某个阶段性里程碑时则理应庆祝一番。</p>
<h3 id="6-项目未设定阶段性的目标"><a href="#6-项目未设定阶段性的目标" class="headerlink" title="6.项目未设定阶段性的目标"></a>6.项目未设定阶段性的目标</h3><h4 id="主要表现-5"><a href="#主要表现-5" class="headerlink" title="主要表现"></a>主要表现</h4><p>项目的关键可交付成果有时也被称作阶段性目标，不仅仅指的是项目的最终成果，还包括用以确保项目顺利进展的阶段性可交付成果。</p>
<p>没有阶段性可交付成果，预示着最终可交付成果的目标麻烦将至。如果要求提交阶段性成果或者最终可交付成果比较混乱，那么就必须借助项目救助方案。</p>
<h4 id="解决对策-5"><a href="#解决对策-5" class="headerlink" title="解决对策"></a>解决对策</h4><p>当项目正处于下滑状态时，项目救助方案是一项旨在迅速改变其方向的阶段性的应对措施。这要求项目团队必须为实现某些利益而做出相应的妥协。同时，救助方案还需要为项目设定发展的步调及氛围，从而使得团队成员能够兴奋起来并做到人尽其才。</p>
<h3 id="7-项目中的人际沟通不顺利"><a href="#7-项目中的人际沟通不顺利" class="headerlink" title="7.项目中的人际沟通不顺利"></a>7.项目中的人际沟通不顺利</h3><h4 id="主要表现-6"><a href="#主要表现-6" class="headerlink" title="主要表现"></a>主要表现</h4><p>在推进项目的进程中，人际关系问题不可避免会发生。然而，对人际关系处理不当，会导致员工离职、员工之间的不愉快、员工士气低下，甚至会出现恃强凌弱、自保反抗、无谓的口水战等局面，以及各个层面上的政治纷争。</p>
<h4 id="解决对策-6"><a href="#解决对策-6" class="headerlink" title="解决对策"></a>解决对策</h4><p>人际关系问题的出现警示我们应该探寻更为深层次的原因。由此而引发的其他问题将会浮出水面，包括质量不过关及贻误最终期限等。</p>
<h3 id="8-项目中出现过多的质量问题"><a href="#8-项目中出现过多的质量问题" class="headerlink" title="8.项目中出现过多的质量问题"></a>8.项目中出现过多的质量问题</h3><h4 id="主要表现-7"><a href="#主要表现-7" class="headerlink" title="主要表现"></a>主要表现</h4><p>质量问题在项目的正常发展阶段也许并不明显，因为现在还尚未交付或尚未实现正常运作的成果可在日后另行交付。然而，质量问题的数量也不能超过一定的界限。质量问题诚然是困难的一种，但是你也可以在出现质量问题时决定是按下求救的按钮，还是认为这尚在可接受的范围之内而予以承受。</p>
<h4 id="解决对策-7"><a href="#解决对策-7" class="headerlink" title="解决对策"></a>解决对策</h4><p>我们应在项目的各个阶段通过回答几个问题，对质量期望值及质量保证流程进行界定：何种类型的错误是可以接受的？错误孰轻孰重，如何解决？应进行怎样的测试，从而发现错误？</p>
<h3 id="9-缺乏项目报告工具"><a href="#9-缺乏项目报告工具" class="headerlink" title="9.缺乏项目报告工具"></a>9.缺乏项目报告工具</h3><h4 id="主要表现-8"><a href="#主要表现-8" class="headerlink" title="主要表现"></a>主要表现</h4><p>你肯定曾经多次听到过这种言论：“别把时间浪费在进度报告上，实实在在地干活才是最重要的。”这种言论背后的观点都是非常高尚的，也可以被运用到任何项目管理工具或程序上。</p>
<p>然而，在宣布进度报告完全无用武之地之前，我们还需要从以下两个方面多加考虑：一是如果出了问题，必须依靠这些报告工具来解决；二是如果没有这些工具，当你知道有问题出现的时候已经悔之晚矣。</p>
<h4 id="解决对策-8"><a href="#解决对策-8" class="headerlink" title="解决对策"></a>解决对策</h4><p>由于缺乏项目报告工具，在那些没有向项目团队进行过汇报或沟通的领域内，一定会出现问题。如能较早发现这些问题，也许能够将其克服。但是，缺乏报告工具通常意味着这些征兆被忽视，知道了就已经晚了。</p>
<h3 id="10-项目工期紧凑"><a href="#10-项目工期紧凑" class="headerlink" title="10.项目工期紧凑"></a>10.项目工期紧凑</h3><h4 id="主要表现-9"><a href="#主要表现-9" class="headerlink" title="主要表现"></a>主要表现</h4><p>有些建设单位（甲方），在工程建设中会突然要求加快进度，比如由于特殊原因工期延误，所以让你在短时间内做好某些分部项目。</p>
<p>关键就在这里，时间越紧凑，施工队伍人手紧张，工作就越忙。这样会存在只求速度、不求质量的现象，有时多督促检查，还稍微好点。否则，工作质量会有很大影响。</p>
<h4 id="解决对策-9"><a href="#解决对策-9" class="headerlink" title="解决对策"></a>解决对策</h4><p>甲方内部一般都是有考核的时间节点，要试着跟甲方的现场管理人员进行沟通，说明情况。不要为了一味地追求速度而忽略了最重要的质量保障。另外，要跟班组长强调，多安排人员轮流干活，如果发现存在质量问题，直接处以罚款。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2020/08/25/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A1%B9%E7%9B%AE%E5%9F%B9%E8%AE%AD%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A1%B9%E7%9B%AE%E5%9F%B9%E8%AE%AD%EF%BC%9F/" class="post-title-link" itemprop="url">如何做好项目培训？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 21:28:24" itemprop="dateCreated datePublished" datetime="2020-08-25T21:28:24+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:54:05" itemprop="dateModified" datetime="2022-09-10T15:54:05+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">项目管理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>项目交付的标准是什么？</p>
<p>通常来说，大部分人（包括项目经理），都会认为是项目验收。<strong>通过内部验收、分项验收、初步验收与竣工验收，一个项目就算完成了从0-1的过程，并且得到了所有重要相关方的检查，可以顺利交付给甲方团队，并且具备了获取尾款的资格。</strong>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/08/25/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A1%B9%E7%9B%AE%E5%9F%B9%E8%AE%AD%EF%BC%9F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2020/02/15/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">金融数据结构--数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-15 13:38:45" itemprop="dateCreated datePublished" datetime="2020-02-15T13:38:45+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:25:39" itemprop="dateModified" datetime="2022-09-10T15:25:39+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" itemprop="url" rel="index"><span itemprop="name">量化交易</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>数据越原始其含有的价值越高</strong>。被处理过的数据虽然用起来很方便，但当你使用时别人很可能已经使用过了。这句话也适用于金融数据 (financial data)。金融数据主要可分为四类，见下表总结。</p>
<p><img src="http://img.9lake.com/uPic/cXMF1b.jpg" alt="cXMF1b"></p>
<p>接下来我们详细讨论它们的特征以及应用。</p>
<h3 id="基本面数据"><a href="#基本面数据" class="headerlink" title="基本面数据"></a>基本面数据</h3><p>**基本面数据 (Fundamental Data) **通常是会计数据  (accounting data)，包括资产 (assets)、负债 (liabilities)、销量 (sales) 和盈利 (earnings) 等等，来源于按季度发布的财务报告。</p>
<p>下图展示了苹果第二季度的财务报表中的部分基本面数据(销量、销售成本、运营费用等等)。</p>
<p><img src="http://img.9lake.com/uPic/exoY4q.jpg" alt="exoY4q"></p>
<p>在使用基本面数据时需注意数据发布日期 (release date) 和季度报告截止日期 (quarter-end reporting period) 不一样！前者一般<strong>晚于</strong>后者 6 周，有时个股的发布日期各不相同。</p>
<p>以茅台 (600519.SH) 举例来看一段万矿 (WindQuant) 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_, date = w.wsd( &quot;600519.SH&quot;,</span><br><span class="line">                 &quot;stm_issuingdate&quot;, </span><br><span class="line">                 &quot;2018-01-01&quot;, &quot;2019-03-31&quot;,</span><br><span class="line">                 &quot;Period=Q;Days=Alldays;Fill=Previous&quot;, </span><br><span class="line">                 usedf=True )</span><br><span class="line">WTable(data = date).plot()</span><br></pre></td></tr></table></figure>

<p>这里 stm_issuingdate 代表「定期报告披露日期」。关于代码里的 wsd 的相关知识，请参考〖Pandas 上〗一贴。</p>
<p><img src="http://img.9lake.com/uPic/yPWy3w.jpg" alt="yPWy3w"></p>
<p>对茅台 2018 年第一季度 (Q2) 来说，发布日期 (2018-08-02) 才是最重要的日期，因为只有发布之后大家才知道基本面数据值 (比如每股收益 EPS)，用报告截止日期 (2018-06-30) 就会引进前视偏差 (look-ahead bias)，因此在 2018-06-30 那天数据没有发布给大众，大众根本不知道 Q2 的 EPS 是多少。</p>
<p>万矿是取每个季度最后一天作为报告期，2018 年的报告期设置分别为</p>
<ul>
<li>一季报：2018-03-31</li>
<li>半年报：2018-06-30</li>
<li>三季报：2018-09-30</li>
<li>年报：2018-12-31</li>
</ul>
<p>下图展示了茅台 2018 年到 2019 年 Q1 的数据发布日期和报告截止日期。</p>
<p><img src="http://img.9lake.com/uPic/cOIi5U.jpg" alt="cOIi5U"></p>
<p>用万矿来查看茅台 2018-06-30 的 EPS 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_, df = w.wsd( &quot;600519.SH&quot;,</span><br><span class="line">               &quot;eps_basic_is&quot;, </span><br><span class="line">               &quot;2018-01-01&quot;, &quot;2019-03-31&quot;,</span><br><span class="line">               &quot;Days=Alldays;rptType=1&quot;, </span><br><span class="line">               usedf=True )</span><br><span class="line">WTable(data = df).plot()</span><br></pre></td></tr></table></figure>

<p>这里 eps_basic_is 代表「基本每股收益」。</p>
<p><img src="http://img.9lake.com/uPic/HliaJ9.jpg" alt="HliaJ9"></p>
<p>我们可以看到 2018-06-30 对应 eps_basic_is 的值为 12.55。由上面日期对比图可知，这个 12.55 的 EPS 应该在 2019-08-02 才发布。因此推断出 2018-06-30 这天的12.55 是从 2019-08-02 那天回填 (backfill) 得到的。</p>
<pre><code>公司披露年报或季报经常会在第一次披露之后发布多个修订版本，对原本缺失的一些数据进行回填。
</code></pre>
<p>继续深挖验证我们的推断。用万矿来查看 2018-08-02 (Q2 数据的发布日) 的 EPS 值。这时 wsd 函数中用参数 fa_eps_basic 而不是用 eps_basic_is，fa_eps_basic 代表「基本每股收益_PIT」。用万矿里的 API 选出 fa_eps_basic 即可，操作非常简单如下屏所示。</p>
<p><img src="http://img.9lake.com/uPic/bXhtEH.jpg" alt="bXhtEH"></p>
<p>上图操作完成之后，查看茅台 2018-06-30 的 EPS_PIT 值 (用的 fa_eps_basic) 的代码自动生成出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_, df = w.wsd( &quot;600519.SH&quot;,</span><br><span class="line">               &quot;fa_eps_basic&quot;, </span><br><span class="line">               &quot;2018-01-01&quot;, &quot;2019-03-31&quot;,</span><br><span class="line">               &quot;Days=Alldays;rptType=1&quot;, </span><br><span class="line">               usedf=True )</span><br><span class="line">WTable(data = df).plot()</span><br></pre></td></tr></table></figure>

<p>PIT 全称是 point-in-time，没有找到很好的中文翻译，就理解成「数据发布的时点」吧。</p>
<p>从下图发现 2018-08-02 的 EPS 值为 12.55，可以确定 2018-06-30 的 EPS 值是回填得来的。</p>
<p><img src="http://img.9lake.com/uPic/QibSlu.jpg" alt="QibSlu"></p>
<p><img src="http://img.9lake.com/uPic/CCTzgl.jpg" alt="CCTzgl"></p>
<p>此外，我们还发现 12.55 对应的起始日 2018-08-02 和终止日 2018-10-28，它们不正是 Q2 的发布日期和 Q3 的发布日期前一天吗？下图就是2018 Q2 到 Q3 的 PIT 数据。</p>
<p><img src="http://img.9lake.com/uPic/r8daMA.jpg" alt="r8daMA"></p>
<p>由于 12.55 是 Q2 截止日 2018-06-30 时 EPS 的值，但是在 Q2 发布日 2018-08-02 才公布于众，直到 2018-10-28。后一天 2018-10-29 是Q3截止日 2018-09-30 时 EPS 的发布日，那么 EPS 也会被更新。</p>
<p>下图给出了一年的 PIT 数据。</p>
<p><img src="http://img.9lake.com/uPic/dXZpgM.jpg" alt="dXZpgM"></p>
<p>使用 PIT 数据可以避免「前视偏差」，自己收集 PIT 的数据太过繁琐，而购买提供 PIT 的数据商又太过昂贵。万矿做得真心不错，免费提供 PIT 数据。</p>
<p>国内有万矿，国外有 Quantopian，下面截屏蓝色高亮那部分说的就是 Quantopian 也考虑了 PIT 而消除了「前视偏差」。</p>
<p><img src="http://img.9lake.com/uPic/xLs3l0.jpg" alt="xLs3l0"></p>
<p>在 Quantopian 用代码看看 Facebook 的基本面数据发布日期 (file_date) 和报告截止日期 (period_ending_date)。关于代码里的 Pipeline 相关知识，请参考〖张量 101〗一贴。</p>
<p><img src="http://img.9lake.com/uPic/25BExY.jpg" alt="25BExY"></p>
<p><img src="http://img.9lake.com/uPic/Tw5Oaa.jpg" alt="Tw5Oaa"></p>
<p>DataFrame 的前五行是 2018 年 1 月 2 日到 8 日的数据要看 2017-09-30 (Q3) 的数据，而其发布日是 2017-11-02。</p>
<p>DataFrame 的后五行意思是 2018 年 12 月 24 日到 31 日的数据要看 2018-09-30 (Q3) 的数据，而其发布日是 2018-10-31。</p>
<p><strong>总结：基本面数据频率低，监管严，易获得，价值可被挖掘的差不多，通常是把基本面数据和其它类数据一起使用。</strong></p>
<h3 id="市场数据"><a href="#市场数据" class="headerlink" title="市场数据"></a>市场数据</h3><p><strong>市场数据 (Market Data)</strong> 包含交易所有类型产品时收集到的数据，包括现货价格 (spot price)、期货价格 (futures price)、利率 (interest rate)、汇率 (exchange rate)、波动率 (volatility)、成交量 (volume) 等等。</p>
<p>在交易中，市场数据以限价定单簿 (limitorder book, LOB) 的形式呈现。每个市场参与者都可从中看到订单信息 (order information)。</p>
<p>以阿里巴巴股票 (BABA) 为例的 LOB 如下图所示。</p>
<p><img src="http://img.9lake.com/uPic/rr0uvP.jpg" alt="rr0uvP"></p>
<p>在 LOB 中，卖家看 Bid，买家看 Ask。LOB 里面有四个重要参数，合称为最佳买卖报价 (Best Bid and Offer, BBO)，分别是</p>
<ul>
<li>买价 (bid price)：卖家可以卖到的最高价 (160 美元)</li>
<li>买量 (bid quantity)：卖家可以卖的数量 (500 股)</li>
<li>卖价 (ask price)：买家可以买到的最低价 (161 美元)</li>
<li>卖量 (ask quantity)：买家可以买的数量 (600 股)</li>
</ul>
<p>在每个时点LOB可以显示三种不同层次的信息。</p>
<h4 id="L1-信息"><a href="#L1-信息" class="headerlink" title="L1 信息"></a>L1 信息</h4><p>如果只看 BABA 的最佳买卖价 (Best Bid and Offer, BBO)，那么它是一维数据 (price)，通常称为 Level 1 (L1) 信息。</p>
<p><img src="http://img.9lake.com/uPic/yXF7XP.jpg" alt="yXF7XP"></p>
<p>卖家可以从市场中以 160 美元卖出 500 股，买家可以从市场中以 161 美元买进 600 股。</p>
<h4 id="L2-信息"><a href="#L2-信息" class="headerlink" title="L2 信息"></a>L2 信息</h4><p>如果还看 BABA 的非最佳买卖价 (Not Best Bid and Offer, NBBO)，那么它是二维数据 (price+depth)，通常称为 Level 2 (L2) 信息。</p>
<p><img src="http://img.9lake.com/uPic/C2wpzd.jpg" alt="C2wpzd"></p>
<p>卖家可以从市场中以 160 美元卖出 500 股，吃完最佳买价 (hitting the bid) 之后，卖家可以继续从市场中以 159 美元卖出 550 股…</p>
<p>买家可以从市场中以 161 美元买进 600 股，吃完最佳卖价(lifting the offer) 之后，买家可以继续从市场中以 162 美元买进 800 股…</p>
<h4 id="L3-信息"><a href="#L3-信息" class="headerlink" title="L3 信息"></a>L3 信息</h4><p>如果在一个价位上，还想区分不同人下单的量 (比如 600 股有 200 是我下的，400 是小明下的，我比小明先下单)，那么它是三维数据(price+depth+size)，通常称为 Level 3 (L3) 信息。</p>
<p><img src="http://img.9lake.com/uPic/6x3OBS.jpg" alt="6x3OBS"></p>
<p>通常数据商提供的是像金融信息交换协议 (Financial Information eXchange, FIX) 类似的原始数据，可以搭建出每个时点的交易账簿 (order book)，更精确点的描述是限价定单簿 (limit order book, LOB)。</p>
<p>CME Globex 是世界上第一个期货电子交易系统，下图是 Globex 里 FIX  的数据结构说明。</p>
<p><img src="http://img.9lake.com/uPic/7eiKYx.jpg" alt="7eiKYx"></p>
<p>从上面表格可看出：</p>
<ul>
<li>第 1 行显示价格的层位(为构建 L2 信息)</li>
<li>第 2 行显示信息发送时间</li>
<li>第 3-4 行显示买价和买量</li>
<li>第 5-6 行显示卖价和卖量</li>
<li>第 7 行显示数据更新状态，0 代表插入新信息，1 代表更新现有信息；2 代表删除老信息</li>
<li>第 8 行显示某层价位的订单数 (为构建 L3 信息)</li>
</ul>
<p>等等。。。</p>
<p>用第 1 到 9 行的信息可以从 FIX 表格重建 L3 的 LOB。</p>
<ul>
<li>side S - 分买入 (bid) 和卖出 (ask)</li>
<li>class – 包含价格 (price) 和成交量 (size)</li>
<li>price level M - LOB 的深度</li>
</ul>
<p>伪代码如下：</p>
<p><img src="http://img.9lake.com/uPic/I0N3qQ.jpg" alt="I0N3qQ"></p>
<p>而第 7 行和 10 到 15 行用来做交易匹配 (trade matching) 的。</p>
<p><strong>总结：基本面数据相比，市场数据更规范，而且频率更高，数据量更大，处理起来也更困难，但是价值更大。</strong></p>
<h3 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h3><p>类比金融产品的原生资产和衍生品的关系，<strong>分析数据 (Analytics Data)</strong> 是原始数据的衍生品，即由原始数据加工得来的。原始数据可以是基本面数据和市场数据，甚至还可以是下节讨论的另类数据。</p>
<p>我们可用</p>
<ul>
<li>销量、成本、运营费用等「基本面数据」来评估一个公司的盈利能力和运营质量，并推荐买卖其股票</li>
<li>限价定单簿和交易信息等「市场数据」来预测冰山单 (iceberg order) 的大小和概率</li>
<li>新闻舆情、财报公告、卫星图像等「另类数据」来做情感分析 (sentiment analysis) 和经营预测</li>
</ul>
<p>下图总结各类原始数据和对应的分析数据。</p>
<p><img src="http://img.9lake.com/uPic/EnlX0n.jpg" alt="EnlX0n"></p>
<p>使用「分析数据」有利有弊</p>
<ul>
<li>优点是特征和信号已经从原始数据中提取出来，使用起来方便</li>
<li>缺点是价格昂贵，而且处理方法不透明 (opaque) 也可能存有偏差 (bias)</li>
</ul>
<h3 id="另类数据"><a href="#另类数据" class="headerlink" title="另类数据"></a>另类数据</h3><p><strong>另类数据 (Alternative Data)</strong> 包括传统数据之外的新的数据，主要成分如下图。</p>
<p><img src="http://img.9lake.com/uPic/KBLB5M.jpg" alt="KBLB5M"></p>
<h4 id="个人数据"><a href="#个人数据" class="headerlink" title="个人数据"></a>个人数据</h4><p>个人数据 (Individual Data) 是由个人网上行为产生的，它还可细分为</p>
<ul>
<li>社交网络数据 (social media data): Twitter, LinkedIn, 微信</li>
<li>新闻舆论数据 (news &amp; reviews data): 新闻、产品舆论</li>
<li>网页搜索数据 (web search data): 谷歌搜索、百度搜索、邮件</li>
</ul>
<p>案例：</p>
<ul>
<li>iSentium 提供交易股票时用到的 Twitter 上的情绪数据指标</li>
<li>RavenPack 提供交易债券、外汇和股票时用到的新闻情绪数据指标</li>
</ul>
<h4 id="商业数据"><a href="#商业数据" class="headerlink" title="商业数据"></a>商业数据</h4><p>商业数据 (Business Process Data) 是由商业流程产生的，它还可细分为</p>
<ul>
<li>交易数据 (transcation data): 主要是消费者交易数据 (Square,Intuit, Xero 等)</li>
<li>公司数据 (corporate data): 主要是行业数据 (AROQ, Edmunds, SNL Financial, Smith Travel 等)</li>
<li>政府机构数据 (government agency data): 国际级别(IMF, WTO, World Bank)，国家级别(美联储, 人民央行)</li>
</ul>
<p>案例</p>
<p>Eagle Alpha 提供交易个股时用到的用户电子邮件收据。</p>
<h4 id="传感数据"><a href="#传感数据" class="headerlink" title="传感数据"></a>传感数据</h4><p>传感数据 (Sensor Data) 是由手机、无人机、卫星上的传感器产生的，它还可细分为</p>
<ul>
<li>卫星图像数据 (satellites images data): 卫星、无人机</li>
<li>地理定位数据 (geolocation data): GPS、手机 APP</li>
<li>天气数据 (weather data)</li>
</ul>
<p>案例：</p>
<ul>
<li>Advan Research 提供交易个股时用手机记录的地理位置数据 (根据人流量预测零售)</li>
<li>RSMetrics 提供交易个股时用无人机拍的停车场和仓库图像数据 (根据车位占满率预测员工)</li>
</ul>
<p>使用「另类数据」有利有弊</p>
<ul>
<li>优点是没被处理过，也没有为其他使用者提供，因此有很高的价值等待发掘，深度学习里的「计算机视觉」和「自然语言处理」的技术可以用来处理图像和文本数据</li>
<li>缺点是「获取昂贵」和「隐私忧患」</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>金融市场数据可分四类，基本面数据、交易数据、分析数据和另类数据。</p>
<p>前三类属于结构性数据 (structured data)，即可以用二维数据表 (excel, DataFrame 等) 储存的；而最后的另类数据属于非结构性数据(unstructured data)，在使用前通常要转换成结构性数据。</p>
<ul>
<li>处理「基本面数据」最容易 (人人可做)，但剩余可发掘的价值也不太高了。</li>
<li>处理「另类数据」最困难 (鲜有人做)，一旦你做了对你的价值是唯一的。</li>
</ul>
<p>有价值的东西做起来从来不容易，如果太容易，大概率没什么价值。有人开玩笑说，如果一套数据集让数据科学家处理起来时很头疼，这套数据集很可能价值很高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/12/15/%E5%9F%BA%E6%9C%AC%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8BMatplotlib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/15/%E5%9F%BA%E6%9C%AC%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8BMatplotlib/" class="post-title-link" itemprop="url">基本可视化之Matplotlib</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-15 11:41:56" itemprop="dateCreated datePublished" datetime="2019-12-15T11:41:56+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:25:20" itemprop="dateModified" datetime="2022-09-10T15:25:20+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Matplotlib 是 Python 中最基本的可视化工具，官网里 ((<a target="_blank" rel="noopener" href="https://matplotlib.org/">https://matplotlib.org/</a>) 有无数好资料，但这不是重点，本文肯定和市面上的所有讲解都不一样。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/15/%E5%9F%BA%E6%9C%AC%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8BMatplotlib/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BPandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BPandas/" class="post-title-link" itemprop="url">数据结构之Pandas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-15 11:39:49" itemprop="dateCreated datePublished" datetime="2019-12-15T11:39:49+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:30:05" itemprop="dateModified" datetime="2022-09-10T15:30:05+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Pandas 是 Python 为解决数据分析而创建的，详情看官网 (<a target="_blank" rel="noopener" href="https://pandas.pydata.org/)%E3%80%82">https://pandas.pydata.org/)。</a> 在使用 pandas 之前，需要引进它，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pandas</span><br></pre></td></tr></table></figure>

<p>这样你就可以用 pandas 里面所有的内置方法 (build-in methods) 了，比如创建一维的 Series 和二维的 DataFrame。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series()</span><br><span class="line">pandas.DataFrame()</span><br></pre></td></tr></table></figure>

<p>但是每次写 pandas 字数有点多，通常我们给 pandas 起个别名 pd，用以下语法，这样所有出现 pandas 的地方都可以用 pd 替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>

<p>Pandas 里面的数据结构是「多维数据表」，学习它可以类比这 NumPy 里的「多维数组」。1&#x2F;2&#x2F;3 维的「多维数据表」分别叫做 Series (系列), DataFrame (数据帧) 和 Panel (面板)，和1&#x2F;2&#x2F;3 维的「多维数组」的类比关系如下。</p>
<p><img src="http://img.9lake.com/uPic/skLkuq.jpg" alt="skLkuq"></p>
<p>由于「系列」、「数据帧」和「面板」这些直译过来的中文名词听起来有些奇怪，在本帖还是直接用 Series, DataFrame 和 Panel。</p>
<p>对比 NumPy (np) 和 Pandas (pd) 每个维度下的数据结构，不难看出</p>
<pre><code>pd 多维数据表 = np 多维数组 + 描述
</code></pre>
<p>其中</p>
<ul>
<li>Series &#x3D; 1darray + index</li>
<li>DataFrame &#x3D; 2darray + index + columns</li>
<li>Panel &#x3D; 3darray + index + columns + item</li>
</ul>
<p>每个维度上的「索引」使得「多维数据表」比「多维数组」涵盖更多的信息，如下图，左边的 2d array 仅仅储存了一组数值 (具体代表什么意思却不知道)，而右边的 DataFrame 一看就知道这是平安银行和茅台从 2018-1-3 到 2019-1-3 的价格。</p>
<p><img src="http://img.9lake.com/uPic/BARYJJ.jpg" alt="BARYJJ"></p>
<p>学习 pandas 遵循的 Python 里「万物皆对象」的原则，既然把数据表当对象，我们就按着数据表的创建、数据表的存载、数据表的获取、数据表的合并和连接、数据表的重塑和透视、和数据表的分组和整合来盘一盘 Pandas。</p>
<h2 id="数据表的创建"><a href="#数据表的创建" class="headerlink" title="数据表的创建"></a>数据表的创建</h2><p>数据表有三大类型</p>
<ul>
<li>Series: 一维数据，类似于 python 中的基本数据的 list 或 NumPy 中的 1D array。Pandas 里最基本的数据结构</li>
<li>DataFrame: 二维数据，类似于 R 中的 data.frame 或 Matlab 中的 Tables。DataFrame 是 Series 的容器</li>
<li>Panel：三维数据。Panel 是 DataFrame 的容器</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><pre><code>最常见的数据类型是二维的 DataFrame，其中

每行代表一个示例 (instance)
每列代表一个特征 (feature)

DataFrame 可理解成是 Series 的容器，每一列都是一个 Series，或者 Series 是只有一列的 DataFrame。

Panel 可理解成是 DataFrame 的容器。
</code></pre>
<p>接下来我们用代码来创建 pandas 数据表，有两种方式：</p>
<ol>
<li>按步就班的用 pd.Series(), pd.DataFrame() 和 pd.Panel()</li>
<li>一步登天的用万矿里面的 WindPy API 读取</li>
</ol>
<h3 id="2-1-按部就班法"><a href="#2-1-按部就班法" class="headerlink" title="2.1 按部就班法"></a>2.1 按部就班法</h3><h4 id="一维Series"><a href="#一维Series" class="headerlink" title="一维Series"></a>一维Series</h4><p>创建 Series 只需用下面一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series( x, index=idx )</span><br></pre></td></tr></table></figure>
<p>其中 x 可以是</p>
<ol>
<li>列表 (list) </li>
<li>numpy 数组 (ndarray)</li>
<li>字典 (dict)</li>
</ol>
<p>x 是位置参数</p>
<p>index 是默认参数，默认值为 idx &#x3D; range(0, len(x))</p>
<h5 id="用列表"><a href="#用列表" class="headerlink" title="用列表"></a>用列表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([27.2, 27.65, 27.70, 28])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 27.20</span><br><span class="line">1 27.65</span><br><span class="line">2 27.70</span><br><span class="line">3 28.00</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>打印出来并不仅仅是列表里面的浮点数，每个浮点数前面还有一个索引，在本例中是 0, 1, 2, 3。</p>
<p>因此在创建 Series 时，如果不显性设定 index，那么 Python 给定一个默认从 0 到 N-1 的值，其中 N 是 x 的长度。</p>
<p>Series s 也是一个对象，用 dir(s) 可看出关于 Series 所有的属性和内置函数，其中最重要的是</p>
<ul>
<li><p>用 s.values 打印 s 中的元素</p>
</li>
<li><p>用 s.index 打印 s 中的元素对应的索引</p>
<p>  s.values</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([27.2 , 27.65, 27.7 , 28. ])</span><br></pre></td></tr></table></figure>
<pre><code>s.index
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RangeIndex(start=0, stop=4, step=1)</span><br></pre></td></tr></table></figure>

<p>不难发现，以上创建的 Series 和 numpy 数组比多了「索引」，但这种 0,1,2,3 的索引是在没有什么描述意义。实际上我们定义的 s 是海底捞在 2019 年 4 月 1 日到 2019 年 4 月 4 日的股价，那么用日期来当索引是不是更好些？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(&#x27;20190401&#x27;,periods=4)</span><br><span class="line">s2 = pd.Series( [27.2, 27.65, 27.70, 28], index=dates )</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 27.20</span><br><span class="line">2019-04-02 27.65</span><br><span class="line">2019-04-03 27.70</span><br><span class="line">2019-04-04 28.00</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>

<p>显然，s2 比 s 包含的信息更多，这是 s2 的索引是一组日期对象，数据类型是 datetime64，频率是 D (天)。</p>
<pre><code>s2.index
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#x27;2019-04-01&#x27;, &#x27;2019-04-02&#x27;, &#x27;2019-04-03&#x27;, &#x27;2019-04-04&#x27;],</span><br><span class="line">dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;D&#x27;)</span><br></pre></td></tr></table></figure>

<p>你甚至还可以给 s2 命名，就叫海底捞股价如何？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2.name = &#x27;海底捞股价&#x27;</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 27.20</span><br><span class="line">2019-04-02 27.65</span><br><span class="line">2019-04-03 27.70</span><br><span class="line">2019-04-04 28.00</span><br><span class="line">Freq: D, Name: 海底捞股价, dtype: float64</span><br></pre></td></tr></table></figure>

<h5 id="用-numpy-数组"><a href="#用-numpy-数组" class="headerlink" title="用 numpy 数组"></a>用 numpy 数组</h5><p>除了用列表，我们还可以用 numpy 数组来生成 Series。在下例中，我们加入缺失值 np.nan，并分析一下 Series 中另外 5 个属性或内置函数的用法：</p>
<ul>
<li>len: s 里的元素个数</li>
<li>shape: s 的形状 (用元组表示)</li>
<li>count: s 里不含 nan 的元素个数</li>
<li>unique: 返回 s 里不重复的元素</li>
<li>value_counts: 统计 s 里非 nan 元素的出现次数</li>
</ul>
<p>对照上面函数的用法，下面的输出一看就懂了吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series( np.array([27.2, 27.65, 27.70, 28, 28, np.nan]) )</span><br><span class="line">print( &#x27;The length is&#x27;, len(s) )</span><br><span class="line">print( &#x27;The shape is&#x27;, s.shape )</span><br><span class="line">print( &#x27;The count is&#x27;, s.count() )</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The length is 6</span><br><span class="line">The shape is (6,)</span><br><span class="line">The count is 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.unique()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([27.2 , 27.65, 27.7 , 28. , nan])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value_counts()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">28.00 2</span><br><span class="line">27.70 1</span><br><span class="line">27.65 1</span><br><span class="line">27.20 1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h5 id="用字典"><a href="#用字典" class="headerlink" title="用字典"></a>用字典</h5><p>创建 Series 还可以用字典。字典的「键值对」的「键」自动变成了 Series 的索引 (index)，而「值」自动变成了Series 的值 (values)。代码如下 (下列用 name 参数来对 s3 命名)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data_dict = &#123; &#x27;BABA&#x27;: 187.07, &#x27;PDD&#x27;: 21.83, &#x27;JD&#x27;: 30.79, &#x27;BIDU&#x27;: 184.77 &#125;</span><br><span class="line">s3 = pd.Series(data_dict, name=&#x27;中概股&#x27;)</span><br><span class="line">s3.index.name = &#x27;股票代号&#x27;</span><br><span class="line">s3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">股票代号</span><br><span class="line">BABA 187.07</span><br><span class="line">PDD 21.83</span><br><span class="line">JD 30.79</span><br><span class="line">BIDU 184.77</span><br><span class="line">Name: 中概股, dtype: float64</span><br></pre></td></tr></table></figure>
<p>给 s3 起名中概股是因为阿里巴巴 (BABA)、拼多多 (PDD)、京东 (JD) 和百度 (BIDU) 都是中国公司但在美国上市的。此外还可以给 index 命名为 ‘股票代号’。</p>
<p>现在假设我们的股票代号为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stock = [&#x27;FB&#x27;, &#x27;BABA&#x27;, &#x27;PDD&#x27;, &#x27;JD&#x27;]</span><br><span class="line">s4 = pd.Series( sdata, index=stock )</span><br><span class="line">s4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FB NaN</span><br><span class="line">BABA 160.0</span><br><span class="line">PDD 28.0</span><br><span class="line">JD 25.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>代号里多加了脸书 (FB)，而 sdata 字典中没有 FB 这个键，因此生成的 s4 在 FB 索引下对应的值为 NaN。再者，代号里没有百度 (BIDU)，因此 s4 里面没有 BIDU 对应的值 (即便 sdata 里面有)。</p>
<p>当两个 Series 进行某种操作时，比如相加，Python 会自动对齐不同 Series 的 index，如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3 + s4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BABA 320.0</span><br><span class="line">BIDU NaN</span><br><span class="line">FB NaN</span><br><span class="line">JD 50.0</span><br><span class="line">PDD 56.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>Series 是 Pandas 里面最基本的数据结构，但是对应每个索引只有一个元素 (比如一个日期对应一个股价)，因此 Series 处理不了每个索引对应多个元素 (比如一个日期对应一个开盘价、收盘价、交易量等等)。而 DataFrame 可以解决这个问题。</p>
<h4 id="二维-DataFrame"><a href="#二维-DataFrame" class="headerlink" title="二维 DataFrame"></a>二维 DataFrame</h4><p>创建 DataFrame 只需用下面一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame( x, index=idx, columns=col )</span><br></pre></td></tr></table></figure>

<p>其中 x 可以是</p>
<ol>
<li>二维列表 (list)</li>
<li>二维 numpy 数组 (ndarray)</li>
<li>字典 (dict)，其值是一维列表、numpy 数组或 Series</li>
<li>另外一个 DataFrame</li>
</ol>
<ul>
<li>x 是位置参数</li>
<li>index 是默认参数，默认值为 idx &#x3D; range(0, x.shape[0])</li>
<li>columns 是默认参数，默认值为 col &#x3D; range(0, x.shape[1])</li>
</ul>
<h5 id="用列表或-numpy-数组"><a href="#用列表或-numpy-数组" class="headerlink" title="用列表或 numpy 数组"></a>用列表或 numpy 数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># df1 = pd.DataFrame( [[1, 2, 3], [4, 5, 6]] )</span><br><span class="line">df1 = pd.DataFrame( np.array([[1, 2, 3], [4, 5, 6]]) )</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/xdQV2m.jpg" alt="xdQV2m"></p>
<p>在创建 DataFrame 时，如果不显性设定 index 和 columns 时，那么Python 给它们默认值，其中</p>
<ul>
<li>index &#x3D; 0 到 r-1，r 是 x 的行数</li>
<li>colmns &#x3D; 0 到 c-1，c 是 x 的列数</li>
</ul>
<h5 id="用对象为列表的字典"><a href="#用对象为列表的字典" class="headerlink" title="用对象为列表的字典"></a>用对象为列表的字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">symbol = [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;AAPL&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;, &#x27;WMT&#x27;]</span><br><span class="line">data = &#123;&#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;电商&#x27;, &#x27;科技&#x27;, &#x27;金融&#x27;, &#x27;金融&#x27;, &#x27;零售&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [176.92, 25.95, 172.97, 41.79, 196.00, 99.55],</span><br><span class="line">        &#x27;交易量&#x27;: [16175610, 27113291, 18913154, 10132145, 2626634, 8086946],</span><br><span class="line">        &#x27;雇员&#x27;: [101550, 175336, 100000, 60348, 36600, 2200000]&#125;</span><br><span class="line">df2 = pd.DataFrame( data, index=symbol )</span><br><span class="line">df2.name=&#x27;美股&#x27;</span><br><span class="line">df2.index.name = &#x27;代号&#x27;</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/I6kbBQ.jpg" alt="I6kbBQ"></p>
<p>字典的「键值对」的「键」自动变成了 DataFrame 的栏 (columns)，而「值」自动变成了 DataFrame 的值 (values)，而其索引 (index) 需要另外定义。</p>
<p>分别来看 df2 的 values, columns 和 index。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.values</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[&#x27;电商&#x27;, 176.92, 16175610, 101550],</span><br><span class="line">       [&#x27;电商&#x27;, 25.95, 27113291, 175336],</span><br><span class="line">       [&#x27;科技&#x27;, 172.97, 18913154, 100000],</span><br><span class="line">       [&#x27;金融&#x27;, 41.79, 10132145, 60348],</span><br><span class="line">       [&#x27;金融&#x27;, 196.0, 2626634, 36600],</span><br><span class="line">       [&#x27;零售&#x27;, 99.55, 8086946, 2200000]], dtype=object)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.columns</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;行业&#x27;, &#x27;价格&#x27;, &#x27;交易量&#x27;, &#x27;雇员&#x27;], dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;AAPL&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;, &#x27;WMT&#x27;],</span><br><span class="line">      dtype=&#x27;object&#x27;, name=&#x27;代号&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>查看 DataFrame</strong></p>
<p>我们可以从头或从尾部查看 DataFrame 的 n 行，分别用 df2.head() 和 df2.tail(n)，如果没有设定 n，默认值为 5 行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.head()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/S7fUxU.jpg" alt="S7fUxU"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.tail(3)</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/QgbgGh.jpg" alt="QgbgGh"></p>
<p><strong>统计 DataFrame</strong></p>
<p>我们用 df2.describe() 还可以看看 DataFrame 每栏的统计数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/QDWKxW.jpg" alt="QDWKxW"></p>
<p>函数 describe() 只对「数值型变量」有用 (没有对「字符型变量」行业栏做统计)，统计量分别包括个数、均值、标准差、最小值，25-50-75 百分数值，最大值。一般做数据分析第一步会用这个表大概看看</p>
<ul>
<li>数据是否有缺失值 (每个栏下的 count 是否相等)？</li>
<li>数据是否有异常值 (最小值 min 和最大值 max 是否太极端)？</li>
</ul>
<p><strong>升维 DataFrame</strong></p>
<p>我们用 MultiIndex.from_tuples() 还可以赋予 DataFrame 多层索引 (实际上增加了维度，多层索引的 DataFrame 实际上是三维数据)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df2.index = pd.MultiIndex.from_tuples( </span><br><span class="line">            [(&#x27;中国公司&#x27;,&#x27;BABA&#x27;), (&#x27;中国公司&#x27;,&#x27;JD&#x27;), </span><br><span class="line">             (&#x27;美国公司&#x27;,&#x27;AAPL&#x27;), (&#x27;美国公司&#x27;,&#x27;MS&#x27;), </span><br><span class="line">             (&#x27;美国公司&#x27;,&#x27;GS&#x27;), (&#x27;美国公司&#x27;,&#x27;WMT&#x27;)] )</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/2e6UxJ.jpg" alt="2e6UxJ"></p>
<p>在 MultiIndex.from_tuples() 中传递一个「元组的列表」，每个元组，比如 (‘中国公司’, ‘BABA’)，第一个元素中国公司是第一层 index，第二个元素BABA是第二层 index。</p>
<p>DataFrame 是 Series 的容器，那什么是 DataFrame 的容器？Panel</p>
<h4 id="三维-Panel"><a href="#三维-Panel" class="headerlink" title="三维 Panel"></a>三维 Panel</h4><p>创建 Panel 只需用下面一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Panel( x, item=itm, major_axis=n1, minor_axis=n2 )</span><br></pre></td></tr></table></figure>

<p>其中 x 可以是</p>
<ol>
<li>三维列表 (list)</li>
<li>三维 numpy 数组 (ndarray)</li>
<li>字典 (dict)，其值是 DataFrame</li>
</ol>
<ul>
<li>x 是位置参数</li>
<li>items 是默认参数 (axis 0)，默认值为 itm &#x3D; range(0, number of DataFrame)</li>
<li>major_axis 是默认参数 (axis 1)，默认值和 DataFrame 的默认 index 一样</li>
<li>minor_axis 是默认参数 (axis 2)，默认值和 DataFrame 的默认 columns 一样</li>
</ul>
<h5 id="用-numpy-数组-1"><a href="#用-numpy-数组-1" class="headerlink" title="用 numpy 数组"></a>用 numpy 数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pn = pd.Panel(np.random.randn(2, 5, 4))</span><br><span class="line">pn</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.panel.Panel&#x27;&gt;</span><br><span class="line">Dimensions: 2 (items) x 5 (major_axis) x 4 (minor_axis)</span><br><span class="line">Items axis: 0 to 1</span><br><span class="line">Major_axis axis: 0 to 4</span><br><span class="line">Minor_axis axis: 0 to 3</span><br></pre></td></tr></table></figure>

<p>Panel pn 含有 2 个 DataFrame，items 为 0, 1；每个 DataFrame 有 5 行 4 列，因此 major_axis 为 0,1,2,3,4，而 minor_axis 为 0,1,2,3。</p>
<h5 id="用对象为-DataFrame-的字典"><a href="#用对象为-DataFrame-的字典" class="headerlink" title="用对象为 DataFrame 的字典"></a>用对象为 DataFrame 的字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(&#x27;20190401&#x27;,periods=4)</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;开盘价&#x27;: [27.2, 27.65, 27.70, 28],</span><br><span class="line">        &#x27;收盘价&#x27;: [27.1, 27.55, 27.45, 28.1]&#125;</span><br><span class="line">df1 = pd.DataFrame( data, index=dates )</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;开盘价&#x27;: [367, 369.8, 378.2, 380.6],</span><br><span class="line">        &#x27;收盘价&#x27;: [369.5, 370.1, 380, 382.1]&#125;</span><br><span class="line">df2 = pd.DataFrame( data, index=dates )</span><br><span class="line"></span><br><span class="line">p_data = &#123;&#x27;海底捞&#x27; : df1, &#x27;腾讯&#x27; : df2&#125;</span><br><span class="line">pn = pd.Panel(p_data)</span><br><span class="line">pn</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.panel.Panel&#x27;&gt;</span><br><span class="line">Dimensions: 2 (items) x 4 (major_axis) x 2 (minor_axis)</span><br><span class="line">Items axis: 海底捞 to 腾讯</span><br><span class="line">Major_axis axis: 2019-04-01 00:00:00 to 2019-04-04 00:00:00</span><br><span class="line">Minor_axis axis: 开盘价 to 收盘价</span><br></pre></td></tr></table></figure>

<p>分析上面的 Panel pn</p>
<ul>
<li><p>有 2 个 DataFrame，items 为 ‘海底捞’ 和 ‘腾讯’</p>
</li>
<li><p>每个 DataFrame 有 4 行 2 列</p>
<ol>
<li>major_axis 从 2019-04-01 到 2019-04-04  </li>
<li>minor_axis 为 ‘开盘价’ 和 ‘收盘价’</li>
</ol>
</li>
</ul>
<p>让我们来查看两个 DataFrame 的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pn[&#x27;海底捞&#x27;]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/VTLIBT.jpg" alt="VTLIBT"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pn[&#x27;腾讯&#x27;]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/jdsf3e.jpg" alt="jdsf3e"></p>
<p>上面这种 Panel 类型的数据在量化投资中还蛮常见，比如我们需要 10 个股票在 1 年时期的 OHLC 价格 (Open, High, Low, Close)，Panel 的 Items, Major_axis 和 Minor_axis 正好可以存储这样的三维数据。如果 Panel 要废掉，那用什么容器来储存三维数据呢？</p>
<p>用多层索引 (Multi-index) 的 DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.concat([df1, df2])</span><br><span class="line">code = [&#x27;海底捞&#x27;, &#x27;腾讯&#x27;]</span><br><span class="line">midx = [ (c, d) for c in code for d in dates ] </span><br><span class="line">df.index =pd.MultiIndex.from_tuples( midx )</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/XfXao5.jpg" alt="XfXao5"></p>
<p>首先用 concat() 函数 (下帖的内容) 将 df1 和 df2 连接起来；再用「列表解析法」生成 midx，它是一个元组的列表，c 是股票代码，d 是日期；最后放入 MultiIndex.from_tuples() 生成有多层索引的 DataFrame。</p>
<h3 id="一步登天法"><a href="#一步登天法" class="headerlink" title="一步登天法"></a>一步登天法</h3><p>上节都是手敲一些数据来创建「多维数据表」的，现实中做量化分析时，数据量都会很大，一般都是从量化平台中或者下载好的 csv 中直接读取。本节介绍如何从量化平台「万矿」中读取数据来创建「多维数据表」的。</p>
<p>首先在 <a target="_blank" rel="noopener" href="https://www.windquant.com/">https://www.windquant.com</a> 注册一个账号，点击「研究」后在点开一个 Notebook 作为你的研究环境 (这是要夸奖一下万矿的 Notebook 体验真的不错，而且数据质量方面还有万德保证)。</p>
<p><img src="http://img.9lake.com/uPic/muybHz.jpg" alt="muybHz"></p>
<p>接着必须加载 WindPy，然后执行 w.start() 启动 API 接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from WindPy import *</span><br><span class="line">w.start()</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/2JPYOm.jpg" alt="2JPYOm"></p>
<p>WindPy 里面有几个获取数据的核心函数，分别是</p>
<ul>
<li>日期序列函数 wsd</li>
<li>多维数据函数 wss</li>
<li>行情数据函数 wsq</li>
<li>分钟序列数据函数 wsi</li>
</ul>
<h4 id="日期序列函数-wsd"><a href="#日期序列函数-wsd" class="headerlink" title="日期序列函数 wsd"></a>日期序列函数 wsd</h4><p>该函数支持股票、债券、基金、期货、指数等多种证券的基本资料、股东信息、市场行情、证券分析、预测评级、财务数据等各种数据，可以支持取单品种单指标、多品种单指标和单品种多指标的时间序列数据 (注：不支持多品种多指标)。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wsd(security, fields, startdate, enddate, options)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>startdate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>enddate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>options &#x3D; 一些特定设置</li>
</ul>
<h5 id="单品种单指标"><a href="#单品种单指标" class="headerlink" title="单品种单指标"></a>单品种单指标</h5><p>获取平安银行在 2019-04-01 到 2019-04-04 的收盘价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = &quot;000001.SZ&quot;</span><br><span class="line">factors = [&quot;close&quot;]</span><br><span class="line">startDate = &quot;2019-04-01&quot;</span><br><span class="line">endDate = &quot;2019-04-04&quot;</span><br><span class="line">data = w.wsd(code, factors, startDate, endDate, usedf=True )</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0, CLOSE</span><br><span class="line">2019-04-01 00:00:00.005 13.18</span><br><span class="line">2019-04-02 00:00:00.005 13.36</span><br><span class="line">2019-04-03 00:00:00.005 13.44</span><br><span class="line">2019-04-04 00:00:00.005 13.86)</span><br></pre></td></tr></table></figure>

<h6 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h6><pre><code>当 usedf=True 时返回元组

- 元组第一个元素为 ErrorCode，其为 0 时表示数据获取正常
- 元组第二个元素为获取的数据 DataFrame，其中 index 列为时间，columns 为参数 Fields 各指标
</code></pre>
<p>上面结果 errorcode &#x3D; 0，要获取 DataFrame 只需访问 data[1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[1]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WlBbHU.jpg" alt="WlBbHU"></p>
<h5 id="单品种多指标"><a href="#单品种多指标" class="headerlink" title="单品种多指标"></a>单品种多指标</h5><p>获取平安银行在 2019-04-01 到 2019-04-04 的开盘价、最低价、最高价和收盘价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = &quot;000001.SZ&quot;</span><br><span class="line">factors = &quot;open,low,high,close&quot;</span><br><span class="line">startDate = &quot;2019-04-01&quot;</span><br><span class="line">endDate = &quot;2019-04-04&quot;</span><br><span class="line">data = w.wsd(code, factors, startDate, endDate, usedf=True )</span><br><span class="line">data[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/FQlT2s.jpg" alt="FQlT2s"></p>
<h5 id="多品种单指标"><a href="#多品种单指标" class="headerlink" title="多品种单指标"></a>多品种单指标</h5><p>获取平安银行、万科、茅台在 2019-04-01 到 2019-04-04 的收盘价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = [&quot;000001.SZ&quot;,&quot;000002.SZ&quot;,&quot;600519.SH&quot;]</span><br><span class="line">factors = &quot;close&quot;</span><br><span class="line">startDate = &quot;2019-04-01&quot;</span><br><span class="line">endDate = &quot;2019-04-04&quot;</span><br><span class="line">data = w.wsd(code, factors, startDate, endDate, usedf=True )</span><br><span class="line">data[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/KhqXy1.jpg" alt="KhqXy1"></p>
<h4 id="多维数据函数-wss"><a href="#多维数据函数-wss" class="headerlink" title="多维数据函数 wss"></a>多维数据函数 wss</h4><p>该函数同样支持股票、债券、基金、期货、指数等多种证券的基本资料、股东信息、市场行情、证券分析、预测评级、财务数据等各种数据。但是 wss 支持取<strong>多品种多指标某个时间点</strong>的截面数据。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wss(security, fields, option)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>options &#x3D; 一些特定设置</li>
</ul>
<p>获取平安银行、万科、茅台在 2018-12-31 的收盘价、交易量、每股盈余和 profit&#x2F;GR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date = &quot;2018-12-31&quot;</span><br><span class="line">codes = [&quot;000001.SZ&quot;,&quot;000002.SZ&quot;,&quot;600519.SH&quot;]</span><br><span class="line">factors = &quot;close, volume, eps_basic, profittogr&quot;</span><br><span class="line">data = w.wss( codes, factors, </span><br><span class="line">              &quot;rptDate=&quot;+date+&quot;;currencyType=&quot;, usedf=True)</span><br><span class="line">data[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/FLv1w2.jpg" alt="FLv1w2"></p>
<p>如果要看财务数据，万矿是取每个季度最后一天作为报告期，如取 2018 年的四个定期报告数据，那报告期设置分别为：</p>
<ul>
<li>一季报：2018-03-31</li>
<li>半年报：2018-06-30</li>
<li>三季报：2018-09-30</li>
<li>年报：   2018-12-31</li>
</ul>
<p>本例 2018-12-31 是年报的数据。</p>
<h4 id="行情数据函数-wsq"><a href="#行情数据函数-wsq" class="headerlink" title="行情数据函数 wsq"></a>行情数据函数 wsq</h4><p>该函数支持股票、债券、基金、期货、指数等多种证券品种的实时行情数据。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wsq(security, fields, func=None)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>func &#x3D; 回调函数</li>
</ul>
<p>获取易方达深证 100ETF 里所有成分中的各种行情指标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ETF = w.wset(&quot;allfundhelddetail&quot;, &quot;rptdate=20181231;windcode=159901.OF&quot;)</span><br><span class="line">codes = ETF.Data[2]</span><br><span class="line">fields = &quot;rt_last,rt_vol,rt_chg,rt_pct_chg,rt_vwap,rt_ask1,rt_bid1&quot;</span><br><span class="line">data = w.wsq( codes, fields )</span><br><span class="line">            </span><br><span class="line">data = pd.DataFrame( data.Data, </span><br><span class="line">                     index=data.Fields, </span><br><span class="line">                     columns=data.Codes).T</span><br><span class="line">data.head(3).append(data.tail(3))</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/LFzLgC.jpg" alt="LFzLgC"></p>
<p>读者肯定好奇第一行代码怎么来的？这里 wset 是专门收集数据集信息的函数，万矿做的好的东西是又一套 GUI 帮你生成第一行代码，展示如下：</p>
<p><img src="http://img.9lake.com/uPic/fPxWA4.jpg" alt="fPxWA4"></p>
<p>点击「API 函数」下面的「WSET 数据集」会带给你以下界面。再选择「ETF 申购成分信息」。</p>
<p><img src="http://img.9lake.com/uPic/X2j3x0.jpg" alt="X2j3x0"></p>
<p>点击下一步得到</p>
<p><img src="http://img.9lake.com/uPic/6NY2dE.jpg" alt="6NY2dE"></p>
<p>看到没有第一行代码就这样生成了，获取数据的门槛迅速降低了好多。</p>
<h4 id="分钟序列数据函数-wsi"><a href="#分钟序列数据函数-wsi" class="headerlink" title="分钟序列数据函数 wsi"></a>分钟序列数据函数 wsi</h4><p>该函数获取选定证券品种的分钟线数据，包含基本行情和部分技术指标的分钟数据，分钟周期为 1-60 min，技术指标参数可以自定义设置。函数定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.wsi(security, fields, starttime = None, endtime = None, options = None)</span><br></pre></td></tr></table></figure>

<ul>
<li>security &#x3D; 证券代号，可以是 str 或 list </li>
<li>fields &#x3D; 指标，可以是 str 或 list</li>
<li>startdate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>enddate &#x3D; 起始日，可以是 str 或 datetime</li>
<li>options &#x3D; 一些特定设置</li>
</ul>
<p>获取中金所 IF 股指期货当月连续合约 2019-04-01 09:30:00 开始至 2019-04-01 09:40:00 的 1 分钟数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">codes =&#x27;IF00.CFE&#x27;</span><br><span class="line">fields =&#x27;open, high, low, close&#x27;</span><br><span class="line">IF = w.wsi( codes, fields, &#x27;2019-04-01 09:30:00&#x27;, &#x27;2019-04-01 09:40:00&#x27;, &quot;&quot;, usedf=True )  </span><br><span class="line">IF[1]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/lllizT.jpg" alt="lllizT"></p>
<h3 id="数据表的存载"><a href="#数据表的存载" class="headerlink" title="数据表的存载"></a>数据表的存载</h3><p>本节讲数据表的「保存」和「加载」，数据的存载没什么技术含量</p>
<ul>
<li>保存只是为了下次再用处理好的 DataFrame</li>
<li>加载可以不用重新再定义 DataFrame</li>
</ul>
<p>DataFrame 可以被保存为 Excel, csv, SQL 和 HDF5 格式，其语句一看就懂，用 to_数据格式，具体如下：</p>
<ul>
<li>to_excel()</li>
<li>to_csv()</li>
<li>to_sql()</li>
<li>to_hdf()</li>
</ul>
<p>如果要加载某种格式的数据到 DataFrame 里，用 read_数据格式，具体如下：</p>
<ul>
<li>read_excel()</li>
<li>read_csv()</li>
<li>read_sql()</li>
<li>read_hdf()</li>
</ul>
<p>我们只用 excel 和 csv 格式举例。</p>
<h4 id="Excel-格式"><a href="#Excel-格式" class="headerlink" title="Excel 格式"></a>Excel 格式</h4><p>用 pd.to_excel 函数将 DataFrame 保存为 .xlsx 格式，并保存到 ‘Sheet1’ 中，具体写法如下：</p>
<pre><code>pd.to_excel( &#39;文件名&#39;，&#39;表名&#39; )
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6]]))</span><br><span class="line">df.to_excel(&#x27;pd_excel.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span><br></pre></td></tr></table></figure>

<p>用 pd.read_excel( ‘文件名’，’表名’ ) 即可加载该文件并存成 DataFrame 形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.read_excel(&#x27;pd_excel.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/wGaDsg.jpg" alt="wGaDsg"></p>
<h4 id="csv-格式"><a href="#csv-格式" class="headerlink" title="csv 格式"></a>csv 格式</h4><p>用 pd.to_csv 函数将 DataFrame 保存为 .csv 格式，注意如果 index 没有特意设定，最后不要把 index 值存到 csv 文件中。具体写法如下：</p>
<pre><code>pd.to_csv( &#39;文件名&#39;，index=False )
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#x27;Code&#x27;: [&#x27;BABA&#x27;, &#x27;00700.HK&#x27;, &#x27;AAPL&#x27;, &#x27;600519.SH&#x27;],</span><br><span class="line">        &#x27;Name&#x27;: [&#x27;阿里巴巴&#x27;, &#x27;腾讯&#x27;, &#x27;苹果&#x27;, &#x27;茅台&#x27;],</span><br><span class="line">        &#x27;Market&#x27;: [&#x27;US&#x27;, &#x27;HK&#x27;, &#x27;US&#x27;, &#x27;SH&#x27;],</span><br><span class="line">        &#x27;Price&#x27;: [185.35, 380.2, 197, 900.2],</span><br><span class="line">        &#x27;Currency&#x27;: [&#x27;USD&#x27;, &#x27;HKD&#x27;, &#x27;USD&#x27;, &#x27;CNY&#x27;]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df.to_csv(&#x27;pd_csv.csv&#x27;, index=False)</span><br></pre></td></tr></table></figure>

<p>用 pd.read_csv( ‘文件名’ ) 即可加载该文件并存成 DataFrame 形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.read_csv(&#x27;pd_csv.csv&#x27;)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ybEt1C.jpg" alt="ybEt1C"></p>
<p>如果一开始储存 df 的时候用 index&#x3D;True，你会发现加载完后的 df2 是以下的样子。</p>
<p><img src="http://img.9lake.com/uPic/UMxxyX.jpg" alt="UMxxyX"></p>
<p>df2 里面第一栏是 df 的 index，由于没有具体的 columns 名称，系统给它一个 “Unamed: 0”。因此在存储 df 的时候，如果 df.index 没有特意设定，记住要在 to_csv() 中把 index 设置为 <strong>False</strong>。</p>
<h3 id="数据表的索引和切片"><a href="#数据表的索引和切片" class="headerlink" title="数据表的索引和切片"></a>数据表的索引和切片</h3><p>由于索引&#x2F;切片 Series 跟 numpy 数组很类似，由于 Panel 在未来会被废掉，因此本节只专注于对 DataFrame 做索引和切片。本节以下面 df 为例做展示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">symbol = [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;AAPL&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;, &#x27;WMT&#x27;]</span><br><span class="line">data = &#123;&#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;电商&#x27;, &#x27;科技&#x27;, &#x27;金融&#x27;, &#x27;金融&#x27;, &#x27;零售&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [176.92, 25.95, 172.97, 41.79, 196.00, 99.55],</span><br><span class="line">        &#x27;交易量&#x27;: [16175610, 27113291, 18913154, 10132145, 2626634, 8086946],</span><br><span class="line">        &#x27;雇员&#x27;: [101550, 175336, 100000, 60348, 36600, 2200000]&#125;</span><br><span class="line">df = pd.DataFrame( data, index=symbol )</span><br><span class="line">df.name=&#x27;美股&#x27;</span><br><span class="line">df.index.name = &#x27;代号&#x27;</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/8Dgvyf.jpg" alt="8Dgvyf"></p>
<p>用不同颜色标注了 df 的 index, columns 和 values，可视图如下：</p>
<p><img src="http://img.9lake.com/uPic/jqxXRs.jpg" alt="jqxXRs"></p>
<p>DataFrame 的索引或切片可以基于标签 (label-based) ，也可以基于位置 (position-based)，不像 numpy 数组的索引或切片只基于位置。</p>
<p>DataFrame 的索引或切片有四大类：</p>
<ul>
<li><p>索引单元素：</p>
<ul>
<li>基于标签的 at</li>
<li>基于位置的 iat</li>
</ul>
</li>
<li><p>切片 columns：</p>
<ul>
<li>用 . 来切片单列</li>
<li>用 [] 来切片单列或多列</li>
<li>基于标签的 loc</li>
<li>基于位置的 iloc</li>
</ul>
</li>
<li><p>切片 index：</p>
<ul>
<li>用 [] 来切片单行或多行</li>
<li>基于标签的 loc</li>
<li>基于位置的 iloc</li>
</ul>
</li>
<li><p>切片 index 和 columns：</p>
<ul>
<li>基于标签的 loc</li>
<li>基于位置的 iloc</li>
</ul>
</li>
</ul>
<p>总体规律，基于标签就用 at 和 loc，基于位置就用 iat 和 iloc。下面我们来一类类分析：</p>
<h4 id="3-1-索引单元素"><a href="#3-1-索引单元素" class="headerlink" title="3.1 索引单元素"></a>3.1 索引单元素</h4><p>两种方法来索引单元素，情况 1 基于标签 at，情况 2 基于位置 iat。</p>
<ul>
<li>情况 1 - df.at[‘idx_i’, ‘attr_j’]</li>
<li>情况 2 - df.iat[i, j]</li>
</ul>
<p>Python 里的中括号 [] 会代表很多意思，比如单元素索引，多元素切片，布尔索引等等，因此让 Python 猜你用的 [] 意图会很低效。如果你想索引单元素，明明白白的用 at 和 iat 效率最高。</p>
<h5 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.at[&#x27;AAPL&#x27;,&#x27;价格&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.97</span><br></pre></td></tr></table></figure>
<p>用 at 获取「行标签」为 ‘AAPL’ 和「列标签」为 ‘价格’ 对应的元素。</p>
<h5 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a>情况 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iat[2,1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.97</span><br></pre></td></tr></table></figure>
<p>用 iat 获取第 3 行第 2 列对应的元素。</p>
<p>索引单元素的总结图：</p>
<p><img src="http://img.9lake.com/uPic/BFKin1.jpg" alt="BFKin1"></p>
<h4 id="3-2-切片-columns"><a href="#3-2-切片-columns" class="headerlink" title="3.2 切片 columns"></a>3.2 切片 columns</h4><h5 id="切片单个-columns"><a href="#切片单个-columns" class="headerlink" title="切片单个 columns"></a>切片单个 columns</h5><p>切片单个 columns 会返回一个 Series，有以下四种情况。情况 1 用点 .；情况 2 用中括号 []；情况 3 基于标签 loc，情况 4 基于位置 iloc。</p>
<ul>
<li>情况 1 - df.attr_i</li>
<li>情况 2 - df[‘attr_i’]</li>
<li>情况 3 - df.loc[:, ‘attr_i’]</li>
<li>情况 4 - df.iloc[:, i]</li>
</ul>
<p>情况 1 记住就可以了，没什么可说的。</p>
<p>情况 2 非常像二维 numpy 数组 arr 的切片，用 arr[i] 就能获取 arr 在「轴 0」上的第 i 个元素 (一个 1darray)，同理 df[‘attr_i’] 也能获取 df 的第 i 个 Series。</p>
<p>情况 3 和 4 的 loc 和 iloc 可类比于上面的 at 和 iat。带 i 的基于位置 (位置用整数表示，i 也泛指整数)，不带 i 的基于标签。里面的冒号 : 代表所有的 index (和 numpy 数组里的冒号意思相同)。</p>
<p>个人建议，如果追求简洁和方便，用 . 和 []；如果追求一致和清晰，用 loc 和 iloc。</p>
<h6 id="情况-1-1"><a href="#情况-1-1" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.价格</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 176.92</span><br><span class="line">JD 25.95</span><br><span class="line">AAPL 172.97</span><br><span class="line">MS 41.79</span><br><span class="line">GS 196.00</span><br><span class="line">WMT 99.55</span><br><span class="line">Name: 价格, dtype: float64</span><br></pre></td></tr></table></figure>
<p>用 . 获取「价格」那一栏下的 Series。</p>
<h6 id="情况-2-1"><a href="#情况-2-1" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;价格&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 176.92</span><br><span class="line">JD 25.95</span><br><span class="line">AAPL 172.97</span><br><span class="line">MS 41.79</span><br><span class="line">GS 196.00</span><br><span class="line">WMT 99.55</span><br><span class="line">Name: 价格, dtype: float64</span><br></pre></td></tr></table></figure>
<p>用 [] 获取「价格」属性下的 Series。</p>
<h6 id="情况-3"><a href="#情况-3" class="headerlink" title="情况 3"></a>情况 3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, &#x27;交易量&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 16175610</span><br><span class="line">JD 27113291</span><br><span class="line">AAPL 18913154</span><br><span class="line">MS 10132145</span><br><span class="line">GS 2626634</span><br><span class="line">WMT 8086946</span><br><span class="line">Name: 交易量, dtype: int64</span><br></pre></td></tr></table></figure>
<p>用 loc 获取「交易量」属性下的 Series。</p>
<h6 id="情况-4"><a href="#情况-4" class="headerlink" title="情况 4"></a>情况 4</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[:, 0]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 电商</span><br><span class="line">JD 电商</span><br><span class="line">AAPL 科技</span><br><span class="line">MS 金融</span><br><span class="line">GS 金融</span><br><span class="line">WMT 零售</span><br><span class="line">Name: 行业, dtype: object</span><br></pre></td></tr></table></figure>
<p>用 iloc 获取第 1 列下的 Series。</p>
<p>切片单个 columns 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/e6vVmL.jpg" alt="e6vVmL"></p>
<h4 id="切片多个-columns"><a href="#切片多个-columns" class="headerlink" title="切片多个 columns"></a>切片多个 columns</h4><p>切片多个 columns 会返回一个 sub-DataFrame (原 DataFrame 的子集)，有以下三种情况。情况 1 用中括号 []；情况 2 基于标签 loc，情况 3 基于位置 iloc。</p>
<ul>
<li>情况 1 - df[[‘attr_i’, ‘attr_j’]]</li>
<li>情况 2 - df.loc[:, ‘attr_i’:’attr_j’]</li>
<li>情况 3 - df.iloc[:, i:j]</li>
</ul>
<p>和切片单个 columns 相比：</p>
<ul>
<li>情况 1 用一个列表来储存一组属性 ‘attr_i’, ‘attr_j’，然后在放进中括号 [] 里获取它们</li>
<li>情况 2 用 ‘attr_i’:’attr_j’ 来获取从属性 i 到属性 j 的 sub-DataFrame</li>
<li>情况 3 用 i:j 来获取从列 i+1 到列 j 的 sub-DataFrame</li>
</ul>
<p>个人建议，如果追求简洁和方便，用 []；如果追求一致和清晰，用 loc 和 iloc。</p>
<h5 id="情况-1-2"><a href="#情况-1-2" class="headerlink" title="情况 1"></a>情况 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ [&#x27;雇员&#x27;, &#x27;价格&#x27;] ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Qucg5s.jpg" alt="Qucg5s"></p>
<p>用 [] 获取「雇员」和「价格」两个属性下的 sub-DataFrame。</p>
<h5 id="情况-2-2"><a href="#情况-2-2" class="headerlink" title="情况 2"></a>情况 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, &#x27;行业&#x27;:&#x27;交易量&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/230g6w.jpg" alt="230g6w"></p>
<p>用 loc 获取从属性 ‘行业’ 到 ‘交易量‘ 的 sub-DataFrame。</p>
<h5 id="情况-3-1"><a href="#情况-3-1" class="headerlink" title="情况 3"></a>情况 3</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[:, 0:2]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/dW5uC2.jpg" alt="dW5uC2"></p>
<p>用 iloc 获取第 1 和 2 列下的 sub-DataFrame。</p>
<p>切片多个 columns 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/hLWFe2.jpg" alt="hLWFe2"></p>
<h4 id="3-3-切片-index"><a href="#3-3-切片-index" class="headerlink" title="3.3 切片 index"></a>3.3 切片 index</h4><h5 id="切片单个-index"><a href="#切片单个-index" class="headerlink" title="切片单个 index"></a>切片单个 index</h5><p>切片<strong>单个</strong> index 有时会返回一个 Series，有以下两种情况。情况 1 基于标签 loc，情况 2 基于位置 iloc。</p>
<ul>
<li>情况 1 - df.loc[‘idx_i’, :]</li>
<li>情况 2 - df.iloc[i, :]</li>
</ul>
<p>切片<strong>单个</strong> index 有时会返回一个只有一行的 DataFrame，有以下两种情况。情况 3 用中括号 [] 加「位置」，情况 4 用中括号 [] 加「标签」。</p>
<ul>
<li>情况 3 - df[i:i+1]</li>
<li>情况 4 - df[‘idx_i’:’idx_i’]</li>
</ul>
<p>情况 1 和 2 的 loc 和 iloc 可类比于上面的 at 和 iat。带 i 的基于位置 (位置用整数表示，i 也泛指整数)，不带 i 的基于标签。里面的冒号 : 代表所有的 columns (和 numpy 数组里的冒号意思相同)。</p>
<p>情况 3 用中括号 [] 加「位置」，位置 i:i+1 有前闭后开的性质。如果要获取第 i+1 行，需要用 i:i+1。</p>
<p>情况 4 用中括号 [] 加「标签」，标签没有前闭后开的性质。如果要获取标签 i，只需要用 ‘idx_i’:’idx_i’。为什么不能只用 ‘idx_i’ 呢？原因是 Python 会把 df[‘idx_i’] 当成切片 columns，然后发现属性中没有 ‘idx_i’ 这一个字符，会报错的。</p>
<p>个人建议，只用 loc 和 iloc。情况 3 太麻烦，获取一行还要用 i:i+1。情况 4 的 df[‘idx_i’] 很容易和切片 columns 中的语句 df[‘attr_j’] 混淆。</p>
<h6 id="情况-1-3"><a href="#情况-1-3" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;GS&#x27;, : ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行业 金融</span><br><span class="line">价格 196</span><br><span class="line">交易量 2626634</span><br><span class="line">雇员 36600</span><br><span class="line">Name: GS, dtype: object</span><br></pre></td></tr></table></figure>

<p>用 loc 获取标签为 ‘GS‘ 的 Series。(GS &#x3D; Goldman Sachs &#x3D; 高盛)</p>
<h6 id="情况-2-3"><a href="#情况-2-3" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[ 3, : ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行业 金融</span><br><span class="line">价格 41.79</span><br><span class="line">交易量 10132145</span><br><span class="line">雇员 60348</span><br><span class="line">Name: MS, dtype: object</span><br></pre></td></tr></table></figure>

<p>用 iloc 获取第 4 行下的 Series。(MS &#x3D; Morgan Stanley &#x3D; 摩根斯坦利)</p>
<h6 id="情况-3-2"><a href="#情况-3-2" class="headerlink" title="情况 3"></a>情况 3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[1:2]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Jesdow.jpg" alt="Jesdow"></p>
<p>用 [1:2] 获取第 2 行的 sub-DataFrame (只有一行)。</p>
<h6 id="情况-4-1"><a href="#情况-4-1" class="headerlink" title="情况 4"></a>情况 4</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;JD&#x27;:&#x27;JD&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ZmpunJ.jpg" alt="ZmpunJ"></p>
<p>用 [‘JD’:’JD’] 获取标签为 ‘JD’ 的 sub-DataFrame (只有一行)。</p>
<p>切片单个 index 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/fIiZ9h.jpg" alt="fIiZ9h"></p>
<h5 id="切片多个-index"><a href="#切片多个-index" class="headerlink" title="切片多个 index"></a>切片多个 index</h5><p>切片多个 index 会返回一个 sub-DataFrame，有以下四种情况。情况 1 用中括号 [] 加「位置」，情况 2 用中括号 [] 加「标签」，情况 3 基于标签 loc，情况 4 基于位置 iloc。</p>
<ul>
<li>情况 1 - df[i:j]</li>
<li>情况 2 - df[‘idx_i’:’idx_j’]</li>
<li>情况 3 - df.loc[‘idx_i’:’idx_j’, :]</li>
<li>情况 4 - df.iloc[i:j, :]</li>
</ul>
<p>和切片单个 index 相比：</p>
<ul>
<li>情况 1 用 [i:j] 来获取行 i+1 到行 j 的 sub-DataFrame</li>
<li>情况 2 用 [‘idx_i’:’idx_j’] 来获取标签 i 到标签 j 的 sub-DataFrame</li>
<li>情况 3 用 loc 加 ‘idx_i’:’idx_j’ 来获取从标签 i 到标签 j 的 sub-DataFrame</li>
<li>情况 4 用 iloc 加 i:j 来获取从行 i+1 到行 j 的 sub-DataFrame</li>
</ul>
<p>个人建议，只用 loc 和 iloc。情况 1 和 2 的 df[] 很容易混淆中括号 [] 里的到底是切片 index 还是 columns。</p>
<h6 id="情况-1-4"><a href="#情况-1-4" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ 1:4 ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WxjryM.jpg" alt="WxjryM"></p>
<p>用 [1:4] 获取第 2 到 4 行的 sub-DataFrame。</p>
<h6 id="情况-2-4"><a href="#情况-2-4" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ &#x27;GS&#x27;:&#x27;WMT&#x27; ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Nyeeeu.jpg" alt="Nyeeeu"></p>
<p>用 [‘GS’:’WMT’] 获取标签从’GS’ 到 ‘WMT’ 的 sub-DataFrame。(WMT &#x3D; Walmart &#x3D; 沃尔玛)</p>
<h6 id="情况-3-3"><a href="#情况-3-3" class="headerlink" title="情况 3"></a>情况 3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;MS&#x27;:&#x27;GS&#x27;, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/yhuWWZ.jpg" alt="yhuWWZ"></p>
<p>用 loc 获取标签从 ‘MS‘ 到 ‘GS’ 的 sub-DataFrame。注意 ‘MS’:’GS’ 要按着 index 里面元素的顺序，要不然会返回一个空的 DataFrame，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;MS&#x27;:&#x27;JD&#x27;, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/5JH9rw.jpg" alt="5JH9rw"></p>
<p>情况 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[ 1:3, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/m7Kaxg.jpg" alt="m7Kaxg"></p>
<p>用 iloc 获取第 2 到 3 行的 sub-DataFrame。</p>
<p>切片多个 index 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/LWmLxI.jpg" alt="LWmLxI"></p>
<h4 id="3-4-切片-index-和-columns"><a href="#3-4-切片-index-和-columns" class="headerlink" title="3.4 切片 index 和 columns"></a>3.4 切片 index 和 columns</h4><p>切片多个 index 和 columns 会返回一个 sub-DataFrame，有以下两种情况。情况 1 基于标签 loc，情况 2 基于位置 iloc。</p>
<ul>
<li>情况 1 - df.loc[‘idx_i’:’idx_j’, ‘attr_k’:’attr_l’]</li>
<li>情况 2 - df.iloc[i:j, k:l]</li>
</ul>
<p>清清楚楚，明明白白，用 loc 和 iloc。</p>
<h6 id="情况-1-5"><a href="#情况-1-5" class="headerlink" title="情况 1"></a>情况 1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ &#x27;GS&#x27;:&#x27;WMT&#x27;, &#x27;价格&#x27;: ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/yoj3Va.jpg" alt="yoj3Va"></p>
<p>用 loc 获取行标签从 ‘GS‘ 到 ‘WMT’，列标签从’价格’到最后的 sub-DataFrame。</p>
<h6 id="情况-2-5"><a href="#情况-2-5" class="headerlink" title="情况 2"></a>情况 2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[ :2, 1:3 ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Bzs3e4.jpg" alt="Bzs3e4"></p>
<p>用 iloc 获取第 1 到 2 行，第 1 到 2 列的 sub-DataFrame。</p>
<p>切片 index 和 columns 的总结图：</p>
<p><img src="http://img.9lake.com/uPic/Nytc8P.jpg" alt="Nytc8P"></p>
<h4 id="3-5-高级索引"><a href="#3-5-高级索引" class="headerlink" title="3.5 高级索引"></a>3.5 高级索引</h4><p>高级索引 (advanced indexing) 可以用布尔索引 (boolean indexing) 和调用函数 (callable function) 来实现，两种方法都返回一组“正确”的索引，而且可以和 loc , iloc , [] 一起套用，具体形式有以下常见几种：</p>
<ul>
<li>df.loc[布尔索引, :] </li>
<li>df.iloc[布尔索引, :] </li>
<li>df[布尔索引] </li>
<li>df.loc[调用函数, :]  </li>
<li>df.iloc[调用函数, :] </li>
<li>df[调用函数]</li>
</ul>
<p>还有以下罕见几种：</p>
<ul>
<li>df.loc[:, 布尔索引] </li>
<li>df.iloc[:, 布尔索引] </li>
<li>df.loc[:, 调用函数]  </li>
<li>df.iloc[:, 调用函数]</li>
</ul>
<p>读者可以想一想为什么第一组形式「常见」而第二组形式「罕见」呢？(<strong>Hint: 看看两组里冒号 : 在不同位置，再想想 DataFrame 每一行和每一列中数据的特点</strong>)</p>
<h5 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h5><p>布尔索引就是用一个由布尔类型值组成的数组来选择元素的方法。</p>
<p>当我们要过滤掉雇员小于 100,000 人的公司，我们可以用 loc 加上布尔索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print( df.雇员 &gt;= 100000 )</span><br><span class="line">df.loc[ df.雇员 &gt;= 100000, : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/p4H6td.jpg" alt="p4H6td"></p>
<p>一种更简便的表达形式是用 df[]，但是我个人不喜欢 []，总觉得会引起「到底在切片 index 还是 columns」的歧义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ df.雇员 &gt;= 100000 ]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.9lake.com/uPic/48Pu5r.jpg" alt="48Pu5r"></p>
<p>现在来看一个「罕见」例子，假如我们想找到所有值为整数型的 columns</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print( df.dtypes == &#x27;int64&#x27; )</span><br><span class="line">df.loc[ :, df.dtypes == &#x27;int64&#x27; ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/E4VBEz.jpg" alt="E4VBEz"></p>
<h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>调用函数是只能有一个参数 (DataFrame, Series) 并返回一组索引的函数。因为调用函数定义在 loc , iloc , [] 里面，因此它就像匿名函数。</p>
<p>当我们要找出交易量大于平均交易量的所有公司，我们可以用 loc 加上匿名函数 (这里 x 代表 df)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ lambda x: x.交易量 &gt; x.交易量.mean() , : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/9Zx3z7.jpg" alt="9Zx3z7"></p>
<p>在上面基础上再加一个条件 – 价格要在 100 之上 (这里 x 还是代表 df)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[ lambda x: (x.交易量 &gt; x.交易量.mean()) &amp; (x.价格 &gt; 100), : ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/z17Ln5.jpg" alt="z17Ln5"></p>
<p>最后来看看价格大于 100 的股票 (注意这里 x 代表 df.价格)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.价格.loc[ lambda x: x &gt; 100 ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代号</span><br><span class="line">BABA 176.92</span><br><span class="line">AAPL 172.97</span><br><span class="line">GS 196.00</span><br><span class="line">Name: 价格, dtype: float64</span><br></pre></td></tr></table></figure>

<h4 id="3-6-多层索引"><a href="#3-6-多层索引" class="headerlink" title="3.6 多层索引"></a>3.6 多层索引</h4><p>在 Panel 那节已经提到过，多层索引可以将「低维数据」升维到「高维数据」，此外，多层索引还可以。。。</p>
<h5 id="多层索引-Series"><a href="#多层索引-Series" class="headerlink" title="多层索引 Series"></a>多层索引 Series</h5><p>首先定义一个 Series，注意它的 index 是一个二维列表，列表第一行 dates 作为第一层索引，第二行 codes 作为第二层索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">price = [190,32,196,192,200,189,31,30,199]</span><br><span class="line">dates = [&#x27;2019-04-01&#x27;]*3 + [&#x27;2019-04-02&#x27;]*2</span><br><span class="line">       +[&#x27;2019-04-03&#x27;]*2 + [&#x27;2019-04-04&#x27;]*2</span><br><span class="line">codes = [&#x27;BABA&#x27;,&#x27;JD&#x27;,&#x27;GS&#x27;,&#x27;BABA&#x27;,&#x27;GS&#x27;,&#x27;BABA&#x27;,&#x27;JD&#x27;,&#x27;JD&#x27;,&#x27;GS&#x27;]</span><br><span class="line"></span><br><span class="line">data = pd.Series( price, index=[ dates, codes ])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 BABA 190</span><br><span class="line">           JD 32</span><br><span class="line">           GS 196</span><br><span class="line">2019-04-02 BABA 192</span><br><span class="line">           GS 200</span><br><span class="line">2019-04-03 BABA 189</span><br><span class="line">           JD 31</span><br><span class="line">2019-04-04 JD 30</span><br><span class="line">           GS 199</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>这个 Series 存储了四天里若干股票的价格，2019-04-01 储存了阿里巴巴、京东和高盛的股价，2019-04-04 只储存了京东和高盛的股价。试想，如果不用多层索引的 Series，我们需要用一个 DataFrame 来存储在这样的数据，把 index 设置成 dates，把 colums 设置成 codes。</p>
<p>让我们看看 Series 的多层 index 是如何表示的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MultiIndex(levels=[[&#x27;2019-04-01&#x27;, &#x27;2019-04-02&#x27;, &#x27;2019-04-03&#x27;, &#x27;2019-04-04&#x27;],</span><br><span class="line">                   [&#x27;BABA&#x27;, &#x27;GS&#x27;, &#x27;JD&#x27;]],</span><br><span class="line">           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3],</span><br><span class="line">                   [0, 2, 1, 0, 1, 0, 2, 2, 1]])</span><br></pre></td></tr></table></figure>

<p>输出是一个 MultiIndex 的对象，里面有 levels 和 labels 二类信息。</p>
<h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><pre><code>索引既然分多层，那么肯定分「内层」和「外层」把，levels 就是描述层的先后的。levels 是一个二维列表，每一行只存储着「唯一」的索引信息：

- dates 是第一层索引，有 4 个「唯一」元素
- codes 是第二层索引，有 3 个「唯一」元素

但是 data 里面有九行啊，4 个 dates 和 3 个 codes 怎么能描述这九行信息呢？这就需要 labels 了。labels 也是一个二维列表：

- 第一行储存 dates 每个元素在 data 里的位置索引
- 第二行储存 codes 每个元素在 data 里的位置索引
</code></pre>
<p>用 [] 加第一层索引可以获取第一层信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[&#x27;2019-04-02&#x27;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BABA 192</span><br><span class="line">GS   200</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>同理，用 loc 加第一层索引也可以切片获取第一层信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[&#x27;2019-04-02&#x27;:&#x27;2019-04-04&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-04-02 BABA 192</span><br><span class="line">           GS 200</span><br><span class="line">2019-04-03 BABA 189</span><br><span class="line">           JD 31</span><br><span class="line">2019-04-04 JD 30</span><br><span class="line">           GS 199</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>此外，切片还可以在不同层上进行，下面 loc  中的冒号 : 表示第一层所有元素，‘GS’ 表示第二层标签为 ‘GS’。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[ :, &#x27;GS&#x27; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-01 196</span><br><span class="line">2019-04-02 200</span><br><span class="line">2019-04-04 199</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h5 id="多层索引-DataFrame"><a href="#多层索引-DataFrame" class="headerlink" title="多层索引 DataFrame"></a>多层索引 DataFrame</h5><p>Series 只有 index，上面刚介绍完多层 index，DataFrame 有 index 和 columns，它们可以设置成多层吗？下面代码用 MultiIndex 函数创建「多层 index 」midx 和「多层columns」mcol。</p>
<p>midx 和 mcol 都是对象，各种都有 levels, labels, names 等性质。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data = [ [&#x27;电商&#x27;, 101550, 176.92, 16175610], </span><br><span class="line">         [&#x27;电商&#x27;, 175336, 25.95, 27113291], </span><br><span class="line">         [&#x27;金融&#x27;, 60348, 41.79, 10132145], </span><br><span class="line">         [&#x27;金融&#x27;, 36600, 196.00, 2626634] ]</span><br><span class="line"></span><br><span class="line">midx = pd.MultiIndex( </span><br><span class="line">          levels=[[&#x27;中国&#x27;,&#x27;美国&#x27;],</span><br><span class="line">                  [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;GS&#x27;, &#x27;MS&#x27;]], </span><br><span class="line">          labels=[[0,0,1,1],[0,1,2,3]],</span><br><span class="line">          names=[&#x27;地区&#x27;, &#x27;代号&#x27;])</span><br><span class="line"></span><br><span class="line">mcol = pd.MultiIndex( </span><br><span class="line">          levels=[[&#x27;公司数据&#x27;,&#x27;交易数据&#x27;],</span><br><span class="line">                  [&#x27;行业&#x27;,&#x27;雇员&#x27;,&#x27;价格&#x27;,&#x27;交易量&#x27;]], </span><br><span class="line">          labels=[[0,0,1,1],[0,1,2,3]],</span><br><span class="line">          names=[&#x27;概括&#x27;,&#x27;细分&#x27;])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, index=midx, columns=mcol)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/BWpKhG.jpg" alt="BWpKhG"></p>
<p>这个 DataFrame 的 index 和 columns 都有两层，严格来说是个四维数据。下面看看如何进行「多层索引」的操作吧。</p>
<p>在第一层 columns 的 ‘公司数据’ 和第二层 columns 的 ‘行业’ 做索引，得到一个含两层 index 的 Series。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1st level-1 column, 2nd level-2 column</span><br><span class="line">df[&#x27;公司数据&#x27;,&#x27;行业&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">地区 代号</span><br><span class="line">中国 BABA 电商</span><br><span class="line">     JD   电商</span><br><span class="line">美国 GS   金融</span><br><span class="line">     MS   金融</span><br><span class="line">Name: (公司数据, 行业), dtype: object</span><br></pre></td></tr></table></figure>

<p>在第一层 index 的 ‘中国’ 做切片，得到一个含两层 columns 的 DataFrame。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[&#x27;中国&#x27;].loc[&#x27;BABA&#x27;:&#x27;JD&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/psuEhC.jpg" alt="psuEhC"></p>
<h5 id="调位-level"><a href="#调位-level" class="headerlink" title="调位 level"></a>调位 level</h5><p>如果你不喜欢 index level 的顺序，可用 swaplevel 将它们调位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.swaplevel(&#x27;地区&#x27;, &#x27;代号&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/InWtze.jpg" alt="InWtze"></p>
<p>如果你不喜欢 columns level 的顺序，也可用 swaplevel 将它们调位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns = df.columns.swaplevel(0,1)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ygIAt6.jpg" alt="ygIAt6"></p>
<h5 id="重设-index"><a href="#重设-index" class="headerlink" title="重设 index"></a>重设 index</h5><p>有时候，一个 DataFrame 的一个或者多个 columns 适合做 index，这时可用 set_index 将它们设置为 index，如果要将 index 还原成 columns，那么用 reset_index 。</p>
<p>看下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#x27;地区&#x27;: [&#x27;中国&#x27;, &#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;美国&#x27;],</span><br><span class="line">        &#x27;代号&#x27;: [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;MS&#x27;, &#x27;GS&#x27;],</span><br><span class="line">        &#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;电商&#x27;, &#x27;金融&#x27;, &#x27;金融&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [176.92, 25.95, 41.79, 196.00],</span><br><span class="line">        &#x27;交易量&#x27;: [16175610, 27113291, 10132145, 2626634],</span><br><span class="line">        &#x27;雇员&#x27;: [101550, 175336, 60348, 36600] &#125;</span><br><span class="line">df = pd.DataFrame( data )</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Kttq8W.jpg" alt="Kttq8W"></p>
<p>将「地区」和「代号」设置为第一层 index 和第二层 index。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.set_index( [&#x27;地区&#x27;,&#x27;代号&#x27;] )</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/XIctGd.jpg" alt="XIctGd"></p>
<p>将所有 index 变成 columns。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.reset_index()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WOCzY6.jpg" alt="WOCzY6"></p>
<h3 id="数据表的合并和连接"><a href="#数据表的合并和连接" class="headerlink" title="数据表的合并和连接"></a>数据表的合并和连接</h3><p>数据表可以按「键」合并，用 merge 函数；可以按「轴」来连接，用 concat 函数。</p>
<h4 id="4-1-合并"><a href="#4-1-合并" class="headerlink" title="4.1 合并"></a>4.1 合并</h4><p>按键 (key) 合并可以分「单键合并」和「多键合并」。</p>
<h5 id="单键合并"><a href="#单键合并" class="headerlink" title="单键合并"></a>单键合并</h5><p>单键合并用 merge 函数，语法如下：</p>
<pre><code>pd.merge( df1, df2, how=s, on=c )
</code></pre>
<p>c 是 df1 和 df2 共有的一栏，合并方式 (how&#x3D;s) 有四种：</p>
<ol>
<li>左连接 (left join)：合并之后显示 df1 的所有行</li>
<li>右连接 (right join)：合并之后显示 df2 的所有行</li>
<li>外连接 (outer join)：合并 df1 和 df2 共有的所有行</li>
<li>内连接 (inner join)：合并所有行 (默认情况)</li>
</ol>
<p>首先创建两个 DataFrame：</p>
<ul>
<li>df_price：4 天的价格 (2019-01-01 到 2019-01-04)</li>
<li>df_volume：5 天的交易量  (2019-01-02 到 2019-01-06)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_price = pd.DataFrame( &#123;&#x27;Date&#x27;: pd.date_range(&#x27;2019-1-1&#x27;, periods=4),</span><br><span class="line">                          &#x27;Adj Close&#x27;: [24.42, 25.00, 25.25, 25.64]&#125;)</span><br><span class="line">df_price</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/aMOHla.jpg" alt="aMOHla"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_volume = pd.DataFrame( &#123;&#x27;Date&#x27;: pd.date_range(&#x27;2019-1-2&#x27;, periods=5), &#x27;Volume&#x27; : [56081400, 99455500, 83028700, 100234000, 73829000]&#125;)</span><br><span class="line">df_volume</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/ZTIGoE.jpg" alt="ZTIGoE"></p>
<p>接下来用 df_price  和 df_volume 展示四种合并。</p>
<h6 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;left&#39; )
</code></pre>
<p>按 df_price 里 Date 栏里的值来合并数据</p>
<ul>
<li>df_volume 里 Date 栏里没有 2019-01-01，因此 Volume 为 NaN</li>
<li>df_volume 里 Date 栏里的 2019-01-05 和 2019-01-06 不在 df_price 里 Date 栏，因此丢弃</li>
</ul>
<h6 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;right&#39; )
</code></pre>
<p><img src="http://img.9lake.com/uPic/fqTCgr.jpg" alt="fqTCgr"></p>
<p>按 df_volume 里 Date 栏里的值来合并数据</p>
<ul>
<li>df_price 里 Date 栏里没有 2019-01-05 和 2019-01-06，因此 Adj Close 为 NaN</li>
<li>df_price 里 Date 栏里的 2019-01-01 不在 df_volume 里 Date 栏，因此丢弃</li>
</ul>
<h6 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;outer&#39; )
</code></pre>
<p><img src="http://img.9lake.com/uPic/WaxZZp.jpg" alt="WaxZZp"></p>
<p>按 df_price 和 df_volume 里 Date 栏里的<strong>所有值</strong>来合并数据</p>
<ul>
<li>df_price 里 Date 栏里没有 2019-01-05 和 2019-01-06，因此 Adj Close 为 NaN</li>
<li>df_volume 里 Date 栏里没有 2019-01-01，因此 Volume 为 NaN</li>
</ul>
<h6 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h6><pre><code>pd.merge( df_price, df_volume, how=&#39;inner&#39; )
</code></pre>
<p><img src="http://img.9lake.com/uPic/IYKcK4.jpg" alt="IYKcK4"></p>
<p>按 df_price 和 df_volume 里 Date 栏里的<strong>共有值</strong>来合并数据</p>
<ul>
<li>df_price 里 Date 栏里的 2019-01-01 不在 df_volume 里 Date 栏，因此丢弃</li>
<li>df_volume 里 Date 栏里的 2019-01-05 和 2019-01-06 不在 df_price 里 Date 栏，因此丢弃</li>
</ul>
<h5 id="多键合并"><a href="#多键合并" class="headerlink" title="多键合并"></a>多键合并</h5><p>多键合并用的语法和单键合并一样，只不过 on&#x3D;c 中的 c 是多栏。</p>
<pre><code>pd.merge( df1, df2, how=s, on=c )
</code></pre>
<p>首先创建两个 DataFrame：</p>
<ul>
<li>portfolio1：3 比产品 FX Option, FX Swap 和 IR Option 的数量</li>
<li>portfolio2：4 比产品 FX Option (重复名称), FX Swap 和 IR Swap 的数量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">porfolio1 = pd.DataFrame(&#123;&#x27;Asset&#x27;: [&#x27;FX&#x27;, &#x27;FX&#x27;, &#x27;IR&#x27;], </span><br><span class="line">                          &#x27;Instrument&#x27;: [&#x27;Option&#x27;, &#x27;Swap&#x27;, &#x27;Option&#x27;], </span><br><span class="line">                          &#x27;Number&#x27;: [1, 2, 3]&#125;)</span><br><span class="line">porfolio1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/TfUZyD.jpg" alt="TfUZyD"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">porfolio2 = pd.DataFrame(&#123;&#x27;Asset&#x27;: [&#x27;FX&#x27;, &#x27;FX&#x27;, &#x27;FX&#x27;, &#x27;IR&#x27;], </span><br><span class="line">                          &#x27;Instrument&#x27;: [&#x27;Option&#x27;, &#x27;Option&#x27;, &#x27;Swap&#x27;, &#x27;Swap&#x27;], </span><br><span class="line">                          &#x27;Number&#x27;: [4, 5, 6, 7]&#125;)</span><br><span class="line">porfolio2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/lSPGUJ.jpg" alt="lSPGUJ"></p>
<p>在 ‘Asset’ 和 ‘Instrument’ 两个键上做外合并。</p>
<p>pd.merge( porfolio1, porfolio2,<br>          on&#x3D;[‘Asset’,’Instrument’],<br>          how&#x3D;’outer’)</p>
<p><img src="http://img.9lake.com/uPic/AEp8yG.jpg" alt="AEp8yG"></p>
<p>df1 和 df2 中两个键都有 FX Option 和 FX Swap，因此可以合并它们中 number 那栏。</p>
<ul>
<li>df1 中有 IR Option 而 df2 中没有，因此 Number_y 栏下的值为 NaN</li>
<li>df2 中有 IR Swap 而 df1 中没有，因此 Number_x 栏下的值为 NaN</li>
</ul>
<p>当 df1 和 df2 有两个相同的列 (Asset 和 Instrument) 时，单单只对一列 (Asset) 做合并产出的 DataFrame 会有另一列 (Instrument) 重复的名称。这时 merge 函数给重复的名称加个后缀 _x, _y 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge( porfolio1, porfolio2,  on=&#x27;Asset&#x27; )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Z9rp6r.jpg" alt="Z9rp6r"></p>
<p>当没设定 merge 函数里参数 how 时，默认为 inner (内合并)。在 Asset 列下，df1 有 2 个 FX 和 1 个 IR，df2 有 3 个 FX 和 1 个 IR，内合并完有 8 行 (2×3+1×1)。</p>
<p>如果觉得后缀 _x, _y 没有什么具体含义时，可以设定 suffixes 来改后缀。比如 df1 和 df2 存储的是 portoflio1 和 portfolio2 的产品信息，那么将后缀该成 ‘1’ 和 ‘2’ 更贴切。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.merge( porfolio1, porfolio2,</span><br><span class="line">          on=&#x27;Asset&#x27;, </span><br><span class="line">          suffixes=(&#x27;1&#x27;,&#x27;2&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/i6WnhT.jpg" alt="i6WnhT"></p>
<h4 id="4-2-连接"><a href="#4-2-连接" class="headerlink" title="4.2 连接"></a>4.2 连接</h4><p>Numpy 数组可相互连接，用 np.concat；同理，Series 也可相互连接，DataFrame 也可相互连接，用 pd.concat。</p>
<h5 id="连接-Series"><a href="#连接-Series" class="headerlink" title="连接 Series"></a>连接 Series</h5><p>在 concat 函数也可设定参数 axis，</p>
<ul>
<li>axis &#x3D; 0 (默认)，沿着轴 0 (行) 连接，得到一个更长的 Series</li>
<li>axis &#x3D; 1，沿着轴 1 (列) 连接，得到一个 DataFrame</li>
</ul>
<p>被连接的 Series 它们的 index 可以重复 (overlapping)，也可以不同。</p>
<h6 id="overlapping-index"><a href="#overlapping-index" class="headerlink" title="overlapping index"></a>overlapping index</h6><p>先定义三个 Series，它们的 index 各不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([0, 1], index=[&#x27;a&#x27;, &#x27;b&#x27;])</span><br><span class="line">s2 = pd.Series([2, 3, 4], index=[&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])</span><br><span class="line">s3 = pd.Series([5, 6], index=[&#x27;f&#x27;, &#x27;g&#x27;])</span><br></pre></td></tr></table></figure>

<p>沿着「轴 0」连接得到一个更长的 Series。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line">a 0</span><br><span class="line">b 1</span><br><span class="line">c 2</span><br><span class="line">d 3</span><br><span class="line">e 4</span><br><span class="line">f 5</span><br><span class="line">g 6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>沿着「轴 1」连接得到一个 DataFrame。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s2, s3], axis=1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/nQyzJR.jpg" alt="nQyzJR"></p>
<h6 id="non-overlapping-index"><a href="#non-overlapping-index" class="headerlink" title="non-overlapping index"></a>non-overlapping index</h6><p>将 s1 和 s3 沿「轴 0」连接来创建 s4，这样 s4 和 s1 的 index 是有重复的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">s4</span><br><span class="line">a 0</span><br><span class="line">b 1</span><br><span class="line">f 5</span><br><span class="line">g 6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>将 s1 和 s4 沿「轴 1」内连接 (即只连接它们共有 index 对应的值)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s4], axis=1, join=&#x27;inner&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/RCvI9E.jpg" alt="RCvI9E"></p>
<h6 id="hierarchical-index"><a href="#hierarchical-index" class="headerlink" title="hierarchical index"></a>hierarchical index</h6><p>最后还可以将 n 个 Series 沿「轴 0」连接起来，再赋予 3 个 keys 创建多层 Series。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat( [s1, s1, s3], keys=[&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">one a 0</span><br><span class="line">    b 1</span><br><span class="line">two a 0</span><br><span class="line">    b 1</span><br><span class="line">three f 5</span><br><span class="line">      g 6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h5 id="连接-DataFrame"><a href="#连接-DataFrame" class="headerlink" title="连接 DataFrame"></a>连接 DataFrame</h5><p>连接 DataFrame 的逻辑和连接 Series 的一模一样。</p>
<h6 id="沿着行连接-axis-x3D-0"><a href="#沿着行连接-axis-x3D-0" class="headerlink" title="沿着行连接 (axis &#x3D; 0)"></a>沿着行连接 (axis &#x3D; 0)</h6><p>先创建两个 DataFrame，df1 和 df2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame( np.arange(12).reshape(3,4), </span><br><span class="line">                    columns=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/zRAv7a.jpg" alt="zRAv7a"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame( np.arange(6).reshape(2,3),</span><br><span class="line">                    columns=[&#x27;b&#x27;,&#x27;d&#x27;,&#x27;a&#x27;])</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/h0DiGw.jpg" alt="h0DiGw"></p>
<p>沿着行连接分两步</p>
<ul>
<li>先把 df1 和 df2 <strong>列标签</strong>补齐</li>
<li>再把 df1 和 df2 <strong>纵向连</strong>起来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat( [df1, df2] )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/X40WuU.jpg" alt="X40WuU"></p>
<p>得到的 DataFrame 的 index &#x3D; [0,1,2,0,1]，有重复值。如果 index 不包含重要信息 (如上例)，可以将 ignore_index 设置为 True，这样就得到默认的 index 值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat( [df1, df2], ignore_index=True )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/FCIuJv.jpg" alt="FCIuJv"></p>
<h6 id="沿着列连接-axis-x3D-1"><a href="#沿着列连接-axis-x3D-1" class="headerlink" title="沿着列连接 (axis &#x3D; 1)"></a>沿着列连接 (axis &#x3D; 1)</h6><p>先创建两个 DataFrame，df1 和 df2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame( np.arange(6).reshape(3,2), </span><br><span class="line">                    index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">                    columns=[&#x27;one&#x27;,&#x27;two&#x27;] )</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/obPARd.jpg" alt="obPARd"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame( 5 + np.arange(4).reshape(2,2), </span><br><span class="line">                    index=[&#x27;a&#x27;,&#x27;c&#x27;], </span><br><span class="line">                    columns=[&#x27;three&#x27;,&#x27;four&#x27;])</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/1zYJ6K.jpg" alt="1zYJ6K"></p>
<p>沿着列连接分两步</p>
<ul>
<li>先把 df1 和 df2 <strong>行标签</strong>补齐</li>
<li>再把 df1 和 df2 <strong>横向</strong>连起来</li>
</ul>
<p>pd.concat( [df1, df2], axis&#x3D;1 )</p>
<p><img src="http://img.9lake.com/uPic/aA8YzM.jpg" alt="aA8YzM"></p>
<h3 id="数据表的重塑和透视"><a href="#数据表的重塑和透视" class="headerlink" title="数据表的重塑和透视"></a>数据表的重塑和透视</h3><p>重塑 (reshape) 和透视 (pivot) 两个操作只改变数据表的布局 (layout)：</p>
<ul>
<li>重塑用 stack 和 unstack 函数 (互为逆转操作)</li>
<li>透视用 pivot 和 melt 函数 (互为逆转操作)</li>
</ul>
<h4 id="5-1-重塑"><a href="#5-1-重塑" class="headerlink" title="5.1 重塑"></a>5.1 重塑</h4><p>DataFrame 和「多层索引的 Series」其实维度是一样，只是展示形式不同。而重塑就是通过改变数据表里面的「行索引」和「列索引」来改变展示形式。</p>
<ul>
<li>列索引 → 行索引，用 stack 函数</li>
<li>行索引 → 列索引，用 unstack 函数</li>
</ul>
<h5 id="单层-DataFrame"><a href="#单层-DataFrame" class="headerlink" title="单层 DataFrame"></a>单层 DataFrame</h5><p>创建 DataFrame df (1 层行索引，1 层列索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">symbol = [&#x27;JD&#x27;, &#x27;AAPL&#x27;]</span><br><span class="line">data = &#123;&#x27;行业&#x27;: [&#x27;电商&#x27;, &#x27;科技&#x27;],</span><br><span class="line">        &#x27;价格&#x27;: [25.95, 172.97],</span><br><span class="line">        &#x27;交易量&#x27;: [27113291, 18913154]&#125;</span><br><span class="line">df = pd.DataFrame( data, index=symbol )</span><br><span class="line">df.columns.name = &#x27;特征&#x27;</span><br><span class="line">df.index.name = &#x27;代号&#x27;</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/i8fBGW.jpg" alt="i8fBGW"></p>
<p>从上表中可知：</p>
<ul>
<li>行索引 &#x3D; [JD, AAPL]，名称是代号</li>
<li>列索引 &#x3D; [行业, 价格, 交易量]，名称是特征</li>
</ul>
<h6 id="stack-列索引-→-行索引"><a href="#stack-列索引-→-行索引" class="headerlink" title="stack: 列索引 → 行索引"></a>stack: 列索引 → 行索引</h6><p>列索引 (特征) 变成了行索引，原来的 DataFrame df 变成了两层 Series (第一层索引是代号，第二层索引是特征)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series = df.stack()</span><br><span class="line">c2i_Series</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号 特征</span><br><span class="line">JD   行业 电商</span><br><span class="line">     价格 25.95</span><br><span class="line">     交易量 27113291</span><br><span class="line">AAPL 行业 科技</span><br><span class="line">     价格 172.97</span><br><span class="line">     交易量 18913154</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p><strong>思考：变成行索引的特征和原来行索引的代号之间的层次是怎么决定的？好像特征更靠内一点，代号更靠外一点。</strong></p>
<h6 id="unstack-行索引-→-列索引"><a href="#unstack-行索引-→-列索引" class="headerlink" title="unstack: 行索引 → 列索引"></a>unstack: 行索引 → 列索引</h6><p>行索引 (代号) 变成了列索引，原来的 DataFrame df 也变成了两层 Series (第一层索引是特征，第二层索引是代号)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2c_Series = df.unstack()</span><br><span class="line">i2c_Series</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特征 代号</span><br><span class="line">行业 JD 电商</span><br><span class="line">     AAPL 科技</span><br><span class="line">价格 JD 25.95</span><br><span class="line">     AAPL 172.97</span><br><span class="line">交易量 JD 27113291</span><br><span class="line">       AAPL 18913154</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<p><strong>思考：变成列索引的特征和原来列索引的代号之间的层次是怎么决定的？这时好像代号更靠内一点，特征更靠外一点。</strong></p>
<h6 id="规律总结"><a href="#规律总结" class="headerlink" title="规律总结"></a>规律总结</h6><p>对 df 做 stack 和 unstack 都得到了「两层 Series」，但是索引的层次不同，那么在背后的规律是什么？首先我们先来看看两个「两层 Series」的 index 包含哪些信息 (以及 df 的 index 和 columns)。</p>
<p>df.index, df.columns</p>
<p><img src="http://img.9lake.com/uPic/UyHwbm.jpg" alt="UyHwbm"></p>
<p>c2i_Series.index</p>
<p><img src="http://img.9lake.com/uPic/HmNCN1.jpg" alt="HmNCN1"></p>
<p>i2c_Series.index</p>
<p><img src="http://img.9lake.com/uPic/3urHvj.jpg" alt="3urHvj"></p>
<p>定义</p>
<ul>
<li>r &#x3D; [JD, AAPL]，名称是代号</li>
<li>c &#x3D; [行业, 价格, 交易量]，名称是特征</li>
</ul>
<p>那么</p>
<ul>
<li>df 的行索引 &#x3D; r</li>
<li>df 的列索引 &#x3D; c</li>
<li>c2i_Series 的索引 &#x3D; [r, c]</li>
<li>i2c_Series 的索引 &#x3D; [c, r]</li>
</ul>
<p>现在可以总结规律：</p>
<ul>
<li>当用 stack 将 df 变成 c2i_Series 时，df 的列索引 c 加在其行索引 r 后面得到 [r, c] 做为 c2i_Series 的多层索引</li>
<li>当用 unstack 将 df 变成 i2c_Series 时，df 的行索引 r 加在其列索引 c 后面得到 [c, r] 做为 i2c_Series 的多层索引</li>
</ul>
<h6 id="基于层和名称来-unstack"><a href="#基于层和名称来-unstack" class="headerlink" title="基于层和名称来 unstack"></a>基于层和名称来 unstack</h6><p>对于多层索引的 Series，unstack 哪一层有两种方法来确定：</p>
<ul>
<li>基于层 (level-based)</li>
<li>基于名称 (name-based)</li>
</ul>
<p>拿 c2i_Series 举例 (读者也可以尝试 i2c_Series)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代号 特征</span><br><span class="line">JD   行业 电商</span><br><span class="line">     价格 25.95</span><br><span class="line">     交易量 27113291</span><br><span class="line">AAPL 行业 科技</span><br><span class="line">     价格 172.97</span><br><span class="line">     交易量 18913154</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>

<ol>
<li>基于层来 unstack() 时，没有填层数，默认为最后一层。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series.unstack()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/PQCq4S.jpg" alt="PQCq4S"></p>
<p>c2i_Series 的最后一层 (看上面它的 MultiIndex) 就是 [行业, 价格, 交易量]，从行索引转成列索引得到上面的 DataFrame。</p>
<ol start="2">
<li>基于层来 unstack() 时，选择第一层 (参数放 0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series.unstack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/YCIPsG.jpg" alt="YCIPsG"></p>
<p>c2i_Series 的第一层 (看上面它的 MultiIndex) 就是 [JD, AAPL]，从行索引转成列索引得到上面的 DataFrame。</p>
<ol start="3">
<li>基于名称来 unstack</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2i_Series.unstack(&#x27;代号&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/SxHDST.jpg" alt="SxHDST"></p>
<p>c2i_Series 的代号层 (看上面它的 MultiIndex) 就是 [JD, AAPL]，从行索引转成列索引得到上面的 DataFrame。</p>
<h5 id="多层-DataFrame"><a href="#多层-DataFrame" class="headerlink" title="多层 DataFrame"></a>多层 DataFrame</h5><p>创建 DataFrame df (2 层行索引，1 层列索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = [ [&#x27;电商&#x27;, 101550, 176.92], </span><br><span class="line">         [&#x27;电商&#x27;, 175336, 25.95], </span><br><span class="line">         [&#x27;金融&#x27;, 60348, 41.79], </span><br><span class="line">         [&#x27;金融&#x27;, 36600, 196.00] ]</span><br><span class="line"></span><br><span class="line">midx = pd.MultiIndex( levels=[[&#x27;中国&#x27;,&#x27;美国&#x27;],</span><br><span class="line">                              [&#x27;BABA&#x27;, &#x27;JD&#x27;, &#x27;GS&#x27;, &#x27;MS&#x27;]], </span><br><span class="line">                      labels=[[0,0,1,1],[0,1,2,3]],</span><br><span class="line">                      names = [&#x27;地区&#x27;, &#x27;代号&#x27;])</span><br><span class="line"></span><br><span class="line">mcol = pd.Index([&#x27;行业&#x27;,&#x27;雇员&#x27;,&#x27;价格&#x27;], name=&#x27;特征&#x27;)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame( data, index=midx, columns=mcol )</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/roWXRN.jpg" alt="roWXRN"></p>
<p>从上表中可知：</p>
<ul>
<li>行索引第一层 &#x3D; r1 &#x3D; [中国, 美国]，名称是地区</li>
<li>行索引第二层 &#x3D; r2 &#x3D; [BABA, JD, GS, MS]，名称是代号</li>
<li>列索引 &#x3D; c &#x3D; [行业, 雇员, 价格]，名称是特征</li>
</ul>
<p>查看 df 的 index 和 columns 的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.index, df.columns</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WN2BuG.jpg" alt="WN2BuG"></p>
<p>那么</p>
<ul>
<li>df 的行索引 &#x3D; [r1, r2]</li>
<li>df 的列索引 &#x3D; c</li>
</ul>
<ol>
<li>基于层来 unstack() 时，选择第一层 (参数放 0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/LlxFB8.jpg" alt="LlxFB8"></p>
<p>df 被 unstack(0) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r2</li>
<li>列索引 &#x3D; [c, r1]</li>
</ul>
<p>重塑后的 DataFrame 这时行索引只有一层 (代号)，而列索引有两层，第一层是特征，第二层是地区。</p>
<ol start="2">
<li>基于层来 unstack() 时，选择第二层 (参数放 1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/fgHf8i.jpg" alt="fgHf8i"></p>
<p>df 被 unstack(1) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>重塑后的 DataFrame 这时行索引只有一层 (地区)，而列索引有两层，第一层是地区，第二层是代号。</p>
<ol start="3">
<li>基于层先 unstack(0) 再 stack(0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(0).stack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/1oQx1g.jpg" alt="1oQx1g"></p>
<p>df 被 unstack(0) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r2</li>
<li>列索引 &#x3D; [c, r1]</li>
</ul>
<p>再被 stack(0) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r2, c]</li>
<li>列索引 &#x3D; r1</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是代号，第二层是特征，而列索引只有一层 (地区)。</p>
<ol start="4">
<li>基于层先 unstack(0) 再 stack(1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(0).stack(1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/oy37su.jpg" alt="oy37su"></p>
<p>df 被 unstack(0) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r2</li>
<li>列索引 &#x3D; [c, r1]</li>
</ul>
<p>再被 stack(1) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r2, r1]</li>
<li>列索引 &#x3D; c</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是代号，第二层是地区，而列索引只有一层 (特征)。</p>
<ol start="5">
<li>基于层先 unstack(1) 再 stack(0)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(1).stack(0)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/IO6u4p.jpg" alt="IO6u4p"></p>
<p>df 被 unstack(1) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>再被 stack(0) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r1, c]</li>
<li>列索引 &#x3D; r2</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是地区，第二层是特征，而列索引只有一层 (代号)。</p>
<ol start="6">
<li>基于层先 unstack(1) 再 stack(1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(1).stack(1)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/R0cl6M.jpg" alt="R0cl6M"></p>
<p>df 被 unstack(1) 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>再被 stack(1) 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r1, r2]</li>
<li>列索引 &#x3D; c</li>
</ul>
<p>重塑后的 DataFrame 这时行索引有两层，第一层是地区，第二层是特征，而列索引只有一层 (代号)。还原成原来的 df 了。</p>
<ol start="7">
<li>基于层被 stack()，没有填层数，默认为最后一层。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.stack()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">地区 代号 特征</span><br><span class="line">中国 BABA 行业 电商</span><br><span class="line">          雇员 101550</span><br><span class="line">          价格 176.92</span><br><span class="line">     JD 行业 电商</span><br><span class="line">        雇员 175336</span><br><span class="line">...</span><br><span class="line">美国 GS 雇员 60348</span><br><span class="line">        价格 41.79</span><br><span class="line">     MS 行业 金融</span><br><span class="line">        雇员 36600</span><br><span class="line">        价格 196</span><br><span class="line">Length: 12, dtype: object</span><br></pre></td></tr></table></figure>

<p>df 被 stack() 之后变成 (列 → 行)</p>
<ul>
<li>行索引 &#x3D; [r1, r2, c]</li>
<li>列索引 &#x3D; []</li>
</ul>
<p>重塑后的 Series 只有行索引，有三层，第一层是地区，第二层是代号，第三层是特征。</p>
<ol start="8">
<li>基于层被 unstack() 两次，没有填层数，默认为最后一层。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack().unstack()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">特征 代号 地区</span><br><span class="line">行业 BABA 中国 电商</span><br><span class="line">          美国 NaN</span><br><span class="line">     JD 中国 电商</span><br><span class="line">        美国 NaN</span><br><span class="line">     GS 中国 NaN</span><br><span class="line">...</span><br><span class="line">价格 JD 美国 NaN</span><br><span class="line">     GS 中国 NaN</span><br><span class="line">        美国 41.79</span><br><span class="line">     MS 中国 NaN</span><br><span class="line">        美国 196</span><br><span class="line">Length: 24, dtype: object</span><br></pre></td></tr></table></figure>

<p>df 被第一次 unstack() 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; r1</li>
<li>列索引 &#x3D; [c, r2]</li>
</ul>
<p>df 被第二次 unstack() 之后变成 (行 → 列)</p>
<ul>
<li>行索引 &#x3D; []</li>
<li>列索引 &#x3D; [c, r2, r1]</li>
</ul>
<p>重塑后的 Series 只有列索引 (实际上是个转置的 Series)，有三层，第一层是特征，第二层是代号，第三层是地区。</p>
<h4 id="5-2-透视"><a href="#5-2-透视" class="headerlink" title="5.2 透视"></a>5.2 透视</h4><p>数据源表通常只包含行和列，那么经常有重复值出现在各列下，因而导致源表不能传递有价值的信息。这时可用「透视」方法调整源表的布局用作更清晰的展示。</p>
<p>#####知识点</p>
<pre><code>本节「透视」得到的数据表和 Excel 里面的透视表 (pivot table) 是一样的。透视表是用来汇总其它表的数据：

1. 首先把源表分组，将不同值当做行 (row)、列 (column) 和值 (value)
1. 然后对各组内数据做汇总操作如排序、平均、累加、计数等

这种动态将·「源表」得到想要「终表」的旋转 (pivoting) 过程，使透视表得以命名。
</code></pre>
<p>在 Pandas 里透视的方法有两种：</p>
<ul>
<li>用 pivot 函数将「一张长表」变「多张宽表」，</li>
<li>用 melt 函数将「多张宽表」变「一张长表」，</li>
</ul>
<p>本节使用的数据描述如下：</p>
<ul>
<li>5 只股票：AAPL, JD, BABA, FB, GS</li>
<li>4 个交易日：从 2019-02-21 到 2019-02-26</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(&#x27;Stock.csv&#x27;, parse_dates=[0], dayfirst=True)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/e6e52i.jpg" alt="e6e52i"></p>
<p>从上表看出有 20 行 (5 × 4) 和 8 列，在 Date 和 Symbol 那两列下就有重复值，4 个日期和 5 个股票在 20 行中分别出现了 5 次和 4 次。</p>
<p>从长到宽 (pivot)</p>
<p>当我们做数据分析时，只关注不同股票在不同日期下的 Adj Close，那么可用 pivot 函数可将原始 data「透视」成一个新的 DataFrame，起名 close_price。在 pivot 函数中</p>
<ul>
<li>将 index 设置成 ‘Date’</li>
<li>将 columns 设置成 ‘Symbol’</li>
<li>将 values 设置 ‘Adj Close’</li>
</ul>
<p>close_price 实际上把 data[‘Date’] 和 data[‘Symbol’] 的唯一值当成支点(pivot 就是支点的意思) 创建一个 DataFrame，其中</p>
<ul>
<li>行标签 &#x3D; 2019-02-21, 2019-02-22, 2019-02-25, 2019-02-26</li>
<li>列标签 &#x3D; AAPL, JD, BABA, FB, GS</li>
</ul>
<p>在把 data[‘Adj Close’] 的值放在以如上的行标签和列标签创建的 close_price 来展示。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">close_price = data.pivot( index=&#x27;Date&#x27;,</span><br><span class="line">                          columns=&#x27;Symbol&#x27;,</span><br><span class="line">                          values=&#x27;Adj Close&#x27; )</span><br><span class="line">close_price</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/DukrkI.jpg" alt="DukrkI"></p>
<p>如果觉得 Adj Close 不够，还想加个 Volume 看看，那么就把 values 设置成 [‘Adj Close’, ‘Volume’]。这时支点还是 data[‘Date’] 和 data[‘Symbol’]，但是要透视的值增加到 data[[‘Adj Close’, ‘Volume’]] 了。pivot 函数返回的是两个透视表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.pivot( index=&#x27;Date&#x27;,</span><br><span class="line">            columns=&#x27;Symbol&#x27;,</span><br><span class="line">            values=[&#x27;Adj Close&#x27;,&#x27;Volume&#x27;] )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/tIMwmQ.jpg" alt="tIMwmQ"></p>
<p>如果不设置 values 参数，那么 pivot 函数返回的是六个透视表。(源表 data 有八列，两列当了支点，剩下六列用来透视)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_pivot = data.pivot( index=&#x27;Date&#x27;, </span><br><span class="line">                        columns=&#x27;Symbol&#x27; )</span><br><span class="line">all_pivot</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/FHXTWu.jpg" alt="FHXTWu"></p>
<p>再继续观察下，all_pivot 实际上是个多层 DataFrame (有多层 columns)。假设我们要获取 2019-02-25 和 2019-02-26 两天的 BABA 和 FB 的开盘价，用以下「多层索引和切片」的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_pivot[&#x27;Open&#x27;].iloc[2:,1:3]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Iqzwtb.jpg" alt="Iqzwtb"></p>
<p><strong>从宽到长 (melt)</strong></p>
<p>pivot 逆反操作是 melt。</p>
<ul>
<li>前者将「一张长表」变成「多张宽表」</li>
<li>后者将「多张宽表」变成「一张长表」</li>
</ul>
<p>具体来说，函数 melt 实际是将「源表」转化成 id-variable 类型的 DataFrame，下例将</p>
<ul>
<li>Date 和 Symbol 列当成 id</li>
<li>其他列 Open, High, Low, Close, Adj Close 和 Volume 当成 variable，而它们对应的值当成 value</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">melted_data = pd.melt( data, id_vars=[&#x27;Date&#x27;,&#x27;Symbol&#x27;] )</span><br><span class="line">melted_data.head(5).append(melted_data.tail(5))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/lc4WCf.jpg" alt="lc4WCf"></p>
<p>新生成的 DataFrame 有 120 行 (4 × 5 × 6)</p>
<ul>
<li>4 &#x3D; data[‘Date’] 有 4 个日期</li>
<li>5 &#x3D; data[‘Symbol’] 有 5 只股票</li>
<li>6 &#x3D; Open, High, Low, Close, Adj Close 和 Volume 这 6 个变量</li>
</ul>
<p>在新表 melted_data 中</p>
<ul>
<li><p>在参数 id_vars 设置的 Date 和 Symbol 还保持为 columns</p>
</li>
<li><p>此外还多出两个 columns，一个叫 variable，一个叫 value</p>
<ul>
<li>variable 列下的值为 Open, High, Low, Close, Adj Close 和 Volume</li>
<li>value 列下的值为前者在「源表 data」中的值</li>
</ul>
</li>
</ul>
<p>函数 melt 可以生成一张含有多个 id 的长表，然后可在 id 上筛选出我们想要的信息，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">melted_data[ lambda x: (x.Date==&#x27;25/02/2019&#x27;) </span><br><span class="line">                     &amp; ((x.Symbol==&#x27;BABA&#x27;)|(x.Symbol==&#x27;FB&#x27;)) ]</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/NIgXqR.jpg" alt="NIgXqR"></p>
<p>在 melted_data 上使用<strong>调用函数</strong> (callable function) 做索引，我们得到了在 2019-02-25 那天 BABA 和 FB 的信息。</p>
<h3 id="数据表的分组和整合"><a href="#数据表的分组和整合" class="headerlink" title="数据表的分组和整合"></a>数据表的分组和整合</h3><p>DataFrame 中的数据可以根据某些规则分组，然后在每组的数据上计算出不同统计量。这种操作称之为 split-apply-combine</p>
<h4 id="6-1-数据准备"><a href="#6-1-数据准备" class="headerlink" title="6.1 数据准备"></a>6.1 数据准备</h4><p>本节使用的数据描述如下：</p>
<ul>
<li>5 只股票：AAPL, JD, BABA, FB, GS</li>
<li>1 年时期：从 2018-02-26 到 2019-02-26</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(&#x27;1Y Stock Data.csv&#x27;, parse_dates=[0], dayfirst=True)</span><br><span class="line">data.head(3).append(data.tail(3))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/9qq3Oh.jpg" alt="9qq3Oh"></p>
<p>我们目前只对 Adj Close 感兴趣，而且想知道在哪一年份或哪一月份每支股票的 Adj Close 是多少。因此我们需要做两件事：</p>
<p>只保留 ‘Date’, ‘Symbol’ 和 ‘Adj Close‘<br>从 ‘Date’ 中获取 ‘Year’ 和 ‘Month’ 的信息并插入表中</p>
<p>将处理过后的数据存在 data1 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data1 = data[[&#x27;Date&#x27;, &#x27;Symbol&#x27;, &#x27;Adj Close&#x27;]]</span><br><span class="line">data1.insert( 1, &#x27;Year&#x27;, pd.DatetimeIndex(data1[&#x27;Date&#x27;]).year )</span><br><span class="line">data1.insert( 2, &#x27;Month&#x27;, pd.DatetimeIndex(data1[&#x27;Date&#x27;]).month )</span><br><span class="line">data1.head(3).append(data1.tail(3))</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/LQeh3U.jpg" alt="LQeh3U"></p>
<h4 id="6-2-分组-grouping"><a href="#6-2-分组-grouping" class="headerlink" title="6.2 分组 (grouping)"></a>6.2 分组 (grouping)</h4><p>用某一特定标签 (label) 将数据 (data) 分组的语法如下：</p>
<pre><code>data.groupBy( label )
</code></pre>
<h5 id="单标签分组"><a href="#单标签分组" class="headerlink" title="单标签分组"></a>单标签分组</h5><p>首先我们按 Symbol 来分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped = data1.groupby(&#x27;Symbol&#x27;)</span><br><span class="line">grouped</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pandas.core.groupby.groupby.DataFrameGroupBy</span><br><span class="line">object at 0x7fbbc7248d68&gt;</span><br></pre></td></tr></table></figure>

<p>又要提起那句说了无数遍的话「万物皆对象」了。这个 grouped 也不例外，当你对如果使用某个对象感到迷茫时，用 dir() 来查看它的「属性」和「内置方法」。以下几个属性和方法是我们感兴趣的：</p>
<ul>
<li>ngroups: 组的个数 (int)</li>
<li>size(): 每组元素的个数 (Series)</li>
<li>groups: 每组元素在原 DataFrame 中的索引信息 (dict)</li>
<li>get_groups(label): 标签 label 对应的数据 (DataFrame)</li>
</ul>
<p>下面看看这些属性和方法的产出结果。</p>
<p>数据里有 5 只股票，因此有 5 组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.ngroups</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>一年有 252 个交易日，因此每只股票含 252 条信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.size()</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol</span><br><span class="line">AAPL 252</span><br><span class="line">BABA 252</span><br><span class="line">FB 252</span><br><span class="line">GS 252</span><br><span class="line">JD 252</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>苹果股票 (AAPL) 的索引从 0 到 251，…，一直到高盛股票 (GS) 的索引从 1008 到 1259。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.groups</span><br></pre></td></tr></table></figure>


<p><img src="http://img.9lake.com/uPic/COuAEk.jpg" alt="COuAEk"></p>
<p>查查 ‘GS’ 组里的数据的前五行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.get_group(&#x27;GS&#x27;).head()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/l2eL53.jpg" alt="l2eL53"></p>
<p>接下来定义个 print_groups 函数便于打印组的名字和前五行信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def print_groups( group_obj ):</span><br><span class="line">    for name, group in group_obj:</span><br><span class="line">        print( name )</span><br><span class="line">        print( group.head() )</span><br></pre></td></tr></table></figure>



<p>用这个函数来调用 grouped (上面用 groupBy 得到的对象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_groups( grouped )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/QGeNbl.jpg" alt="QGeNbl"></p>
<p>这个 print_groups 函数在下面也多次被用到。</p>
<h5 id="多标签分组"><a href="#多标签分组" class="headerlink" title="多标签分组"></a>多标签分组</h5><p>groupBy 函数除了支持单标签分组，也支持多标签分组 (将标签放入一个列表中)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped2 = data1.groupby([&#x27;Symbol&#x27;, &#x27;Year&#x27;, &#x27;Month&#x27;])</span><br><span class="line">print_groups( grouped2 )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/PYPFat.jpg" alt="PYPFat"></p>
<p><img src="http://img.9lake.com/uPic/MBSKV8.jpg" alt="MBSKV8"></p>
<p>不难看出在每组左上方，有一个 (Symbol, Year, Month) 元组型的标识：</p>
<ul>
<li>第一组：(‘AAPL’, 2018, 2)</li>
<li>最后一组：(‘JD’, 2019, 2)</li>
</ul>
<p>还记得的重设索引 (set_index) 的操作么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data2 = data1.set_index([&#x27;Symbol&#x27;, &#x27;Year&#x27;, &#x27;Month&#x27;])</span><br><span class="line">data2.head().append(data2.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/c9Kb1k.jpg" alt="c9Kb1k"></p>
<p>对 data1 重设索引之后，产出是一个有 multi-index 的 DataFrame，记做 data2。由于有多层索引，这时我们根据索引的 level 来分组，下面 level &#x3D; 1 就是对第一层 (Year) 进行分组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped3 = data2.groupby(level=1)</span><br><span class="line">print_groups( grouped3 )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/Kn1cWM.jpg" alt="Kn1cWM"></p>
<p>注意每组<strong>左上方</strong>的标识是  Year。</p>
<p>多层索引中的任意个数的索引也可以用来分组，下面 level &#x3D; [0,2] 就是对第零层 (Symbol) 和第二层 (Month) 进行分组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped4 = data2.groupby(level=[0, 2])</span><br><span class="line">print_groups( grouped4 )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/WCmBXk.jpg" alt="WCmBXk"></p>
<p><img src="http://img.9lake.com/uPic/fcQxXH.jpg" alt="fcQxXH"></p>
<p>注意每组左上方的标识是 (Symbol, Month)。</p>
<h4 id="6-3-整合-aggregating"><a href="#6-3-整合-aggregating" class="headerlink" title="6.3 整合 (aggregating)"></a>6.3 整合 (aggregating)</h4><p>做完分组之后 so what？当然是在每组做点数据分析再整合啦。</p>
<p>一个最简单的例子就是上节提到的 size() 函数，用 grouped 对象 (上面根据 Symbol 分组得到的) 来举例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.size()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol</span><br><span class="line">AAPL 252</span><br><span class="line">BABA 252</span><br><span class="line">FB 252</span><br><span class="line">GS 252</span><br><span class="line">JD 252</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>一个更实际的例子是用 mean() 函数计算每个 Symbol 下 1 年时期的股价均值。在获取任意信息就用 DataFrame 的索引或切片那一套方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped.mean()</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/TFJohc.jpg" alt="TFJohc"></p>
<p>除了上述方法，整合还可以用内置函数 aggregate() 或 agg() 作用到「组对象」上。用 grouped4 对象 (上面根据 Symbol, Year, Month 分组得到的) 来举例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = grouped4.agg( np.mean )</span><br><span class="line">result.head().append(result.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/4ynBBL.jpg" alt="4ynBBL"></p>
<p>函数 agg() 其实是一个高阶函数里面的参数可以是另外一个函数，比如上例的 np.mean。上面代码对每只股票在每年每个月上求均值。</p>
<p>那么参数可以是另外一组函数么？可以的！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = grouped4.agg( [np.mean, np.std] )</span><br><span class="line">result.head().append(result.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/weahpH.jpg" alt="weahpH"></p>
<p>将 np.mean 和 np.std 放进列表中，当成是高阶函数 agg() 的参数。上面代码对每只股票在每年每个月上求均值和标准差。</p>
<p>既然 agg() 是高阶函数，参数当然也可以是匿名函数 (lambda 函数)，下面我们定义一个对 grouped 里面每个标签下求最大值和最小值，再求差。注意 lambda 函数里面的 x 就是 grouped。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = grouped.agg( lambda x: np.max(x)-np.min(x) )</span><br><span class="line">result.head().append(result.tail())</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/zd1W8V.jpg" alt="zd1W8V"></p>
<p>上面代码对每只股票在 Date, Year, Month 和 Adj Close 上求「最大值」和「最小值」的差。真正有价值的信息在 Adj Close 那一栏，但我们来验证一下其他几栏。</p>
<ul>
<li>Date: 365 days，合理，一年数据</li>
<li>Year: 1，合理，2019 年和 2018 年</li>
<li>Month: 11，合理，12 月和 1 月。</li>
</ul>
<h4 id="6-4-split-apply-combine"><a href="#6-4-split-apply-combine" class="headerlink" title="6.4 split-apply-combine"></a>6.4 split-apply-combine</h4><p>前几节做的事情的实质就是一个 split-apply-combine 的过程，如下图所示：</p>
<p><img src="http://img.9lake.com/uPic/1teLhF.jpg" alt="1teLhF"></p>
<p>该 split-apply-combine 过程有三步：</p>
<ol>
<li>根据 key 来 split 成 n 组</li>
<li>将函数 apply 到每个组</li>
<li>把 n 组的结果 combine 起来</li>
</ol>
<p>在看具体例子之前，我们先定一个 top 函数，返回 DataFrame 某一栏中 n 个最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def top( df, n=5, column=&#x27;Volume&#x27; ):</span><br><span class="line">    return df.sort_values(by=column)[-n:]</span><br></pre></td></tr></table></figure>

<p>将 top 函数用到最原始的数据 (从 csv 中读取出来的) 上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top( data )</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/urWYaU.jpg" alt="urWYaU"></p>
<p>从上表可看出，在 Volume 栏取 5 个最大值。</p>
<h5 id="Apply-函数"><a href="#Apply-函数" class="headerlink" title="Apply 函数"></a>Apply 函数</h5><p>在 split-apply-combine 过程中，apply 是核心。Python 本身有高阶函数 apply() 来实现它，既然是高阶函数，参数可以是另外的函数了，比如刚定义好的 top()。</p>
<p>将 top() 函数 apply 到按 Symbol 分的每个组上，按每个 Symbol 打印出来了 Volume 栏下的 5 个最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.groupby(&#x27;Symbol&#x27;).apply(top)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/tM0EIW.jpg" alt="tM0EIW"></p>
<p>上面在使用 top() 时，对于 n 和 column 我们都只用的默认值 5 和 ‘Volumn’。如果用自己设定的值 n &#x3D; 1, column &#x3D; ‘Adj Close’，写法如下(下面使用在元数据上插入 Year 和 Month 的数据)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data1.groupby([&#x27;Symbol&#x27;,&#x27;Year&#x27;]).apply(top, n=1, column=&#x27;Adj Close&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.9lake.com/uPic/J6cyF9.jpg" alt="J6cyF9"></p>
<p>按每个 Symbol 和 Year 打印出来了 Adj Close 栏下的最大值。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Pandas 里面的数据结构是多维数据表，细化为一维的 Series，二维的 DataFrame，三维的 Panel。</p>
<pre><code>多维数据表 = 多维数组 + 描述
</code></pre>
<p>其中</p>
<ul>
<li>Series &#x3D; 1darray + index</li>
<li>DataFrame &#x3D; 2darray + index + columns</li>
<li>Panel &#x3D; 3darray + index + columns + item</li>
</ul>
<p>pd 多维数据表和 np 多维数组之间的类比关系如下图所示。</p>
<p><img src="http://img.9lake.com/uPic/Qnzeq3.jpg" alt="Qnzeq3"></p>
<p><strong>【创建数据表】</strong>创建 Series, DataFrame, Panel 用下面语句</p>
<ul>
<li>pd.Series(x, index&#x3D;idx)</li>
<li>pd.DataFrame(x, index&#x3D;idx, columns&#x3D;col)</li>
<li>pd.Panel(x, item&#x3D;itm, major_axis&#x3D;n1, minor_axis&#x3D;n2)</li>
</ul>
<p>DataFrame 由多个 Series 组成，Panel 有多个 DataFrame 组成。Series 非常类似于一维的 DataFrame，Panel 未来会被废掉，因此学 Pandas 把注意力放在 DataFrame 上即可。</p>
<p><strong>【索引和切片数据表】</strong>在索引或切片 DataFrame，有很多种方法。最好记的而不易出错的是用基于位置的 at 和 loc，和基于标签的 iat 和 iloc，具体来说，索引用 at 和 iat，切片用 loc 和 iloc。带 i 的基于位置，不带 i 的基于标签。</p>
<p>用 MultiIndex 可以创建多层索引的对象，获取 DataFrame df 的信息可用</p>
<ul>
<li>df.loc[1st].loc[2nd]</li>
<li>df.loc[1st].iloc[2nd]</li>
<li>df.iloc[1st].loc[2nd]</li>
<li>df.iloc[1st].iloc[2nd]</li>
</ul>
<p>要调换 level 可用</p>
<ul>
<li>df.index.swaplevel(0,1)</li>
<li>df.columns.swaplevel(0,1)</li>
</ul>
<p>要设置和重设 index 可用</p>
<ul>
<li>df.set_index( columns )</li>
<li>df.reset_index</li>
</ul>
<p><strong>【合并数据表】</strong> 用 merge 函数按数据表的共有列进行左&#x2F;右&#x2F;内&#x2F;外合并。</p>
<p><img src="http://img.9lake.com/uPic/vlLEzQ.jpg" alt="vlLEzQ"></p>
<p>【连接数据表】用 concat 函数对 Series 和 DataFrame 沿着不同轴连接。</p>
<p>【重塑数据表】用 stack 函数将「列索引」变成「行索引」，用 unstack 函数将「行索引」变成「列索引」。它们只是改变数据表的布局和展示方式而已。</p>
<p><img src="http://img.9lake.com/uPic/eDp66D.jpg" alt="eDp66D"></p>
<p><img src="http://img.9lake.com/uPic/ojKysH.jpg" alt="ojKysH"></p>
<p><img src="http://img.9lake.com/uPic/JlrQJW.jpg" alt="JlrQJW"></p>
<p>【透视数据表】用 pivot 函数将「一张长表」变成「多张宽表」，用 melt 函数将「多张宽表」变成「一张长表」。它们只是改变数据表的布局和展示方式而已。</p>
<p><img src="http://img.9lake.com/uPic/k5UEPK.jpg" alt="k5UEPK"></p>
<p><img src="http://img.9lake.com/uPic/1MEZmp.jpg" alt="1MEZmp"></p>
<p>【分组数据表】用 groupBy 函数按不同「列索引」下的值分组。一个「列索引」或多个「列索引」就可以。</p>
<p>【整合数据表】用 agg 函数对每个组做整合而计算统计量。</p>
<p>【split-apply-combine】用 apply 函数做数据分析时美滋滋。</p>
<p><img src="http://img.9lake.com/uPic/fPakDK.jpg" alt="fPakDK"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSklearn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSklearn/" class="post-title-link" itemprop="url">机器学习之Sklearn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-14 21:10:17" itemprop="dateCreated datePublished" datetime="2019-12-14T21:10:17+08:00">2019-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:24:47" itemprop="dateModified" datetime="2022-09-10T15:24:47+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Sklearn (全称 Scikit-Learn) 是基于 Python 语言的机器学习工具。它建立在 NumPy, SciPy, Pandas 和 Matplotlib 之上，里面的 API 的设计非常好，所有对象的接口简单，很适合新手上路。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSklearn/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/10/31/%CE%B1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%CE%B1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0/" class="post-title-link" itemprop="url">α的三要素</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 22:40:36" itemprop="dateCreated datePublished" datetime="2019-10-31T22:40:36+08:00">2019-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:33:18" itemprop="dateModified" datetime="2022-09-10T15:33:18+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" itemprop="url" rel="index"><span itemprop="name">量化交易</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="何为三要素"><a href="#何为三要素" class="headerlink" title="何为三要素"></a>何为三要素</h3><p>主动投资管理的先驱之一Richard Grinold写过一篇著名的文章，题为《α &#x3D; Volatility × IC × Score》。这篇文章标题直白醒目，简明扼要的说明了在主动管理中寻求股票α收益率的三要素。</p>
<p>Grinold对α的定义为个股收益率中无法被与市场收益率相关的β部分解释的残余部分。假设r为个股相对无风险收益率的超额收益，r<sub>m</sub>为市场相对无风险收益率的超额收益，那么我们有</p>
<p>r &#x3D; α + β × r<sub>m</sub></p>
<p>如果个股的α都是零（就像CAPM假设的那样），那么我们买个指数就万事大吉，所有主动型基金经理都会失业。但现实并不是这样，一些股票的确存在正的α，而另一些存在负的α。主动投资管理就是从所有的股票中选出拥有超额α收益的那些优秀股票。</p>
<p>让我们假设为了挖掘有真正α的优秀股票，某主动型基金经理有一个模型（咱们先甭管这个模型是怎么得到的，也许是靠着手底下众多研究员的深度研究，也许是靠着科学的量化分析，也许是靠打听内部消息，也许是靠猴子扔飞镖，whatever，you name it）。每当这个基金经理要预测个股下一期的α收益时，这个模型便给出一个预测，记为f。</p>
<p>这样α的三要素为IC、Volatility以及Score：</p>
<p><strong>IC</strong>：它是对α的预测（即f）和实际α的相关系数，在这里被称为信息系数Information Coefficient。显然，这个相关度越高越好，它最直接的反映基金经理在主动管理中的预测能力。</p>
<p><strong>Volatility</strong>：代表的是个股α本身的波动。α本身的波动越大，说明越有机会可图。举个极端的例子，如果α &#x3D; 0或者一个恒定的常数，那么这支个股对所有人来说都是一样的，根本没有α可以挖掘。</p>
<p><strong>Score</strong>：这是一个把当期对α的预测值f按照过去的预测进行标准化后的一个标准化分数。它代表了在此时此刻，该基金经理对这支股票的看好的程度。这么说也许不够直白。举个例子来说，假设这个基金经理有一个非常厉害的模型，每次都能预测个八九不离十，这次的预测值f为-1%，假设它标准化后的分数为-2。因此score就等于-2，说明该模型在当期对这支股票相当不看好。</p>
<h3 id="数学含义"><a href="#数学含义" class="headerlink" title="数学含义"></a>数学含义</h3><p>在这篇文章中，Grinold虽然使用了大量的例子来阐述这三要素在解释α时发挥的作用，但它并没有具体给出公式α &#x3D; Volatility×IC×Score的推导。下面我们就来从数学上说明这个公式的美妙之处，它可以通过对α收益率以及它的预测值f的历史时间序列进行线性回归来得到。</p>
<p>用时间序列f对时间序列α做线性回归模型有：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hrege0nvj30im06mgm8.jpg"></p>
<p>其中，a和b是回归系数，ε是回归误差，一般假设ε的期望为0。通过历史数据，利用最小二乘法对上述模型求解可以得到参数a和b的最优值：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hrf5fl9oj30nw0c2die.jpg"></p>
<p>将得到的a和b的最优参数带回到上面的回归模型中，并舍去回归误差项，可得：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hrfwqi1qj30xk0l443w.jpg"></p>
<p>由于E[α]是α的历史均值，对任何一期的α都是一样的，因此真正影响α的是后面这三项的乘积，即α &#x3D; IC×Volatility×Score。</p>
<p>如果用一句话来说清楚这个α公式的含义就是：<strong>如果股票本身有α可以挖掘（α的Volatility波动率大）、我有一个准确的预测方法（在历史上预测值f和α之间的IC高），并且当期我的预测值f非常好（我对这个股票非常有信心），那么我就可以预期这支股票在未来有不错的超额收益α。</strong></p>
<p>在这三要素中，α自身的波动由股票所处的行业和公司的性质所决定。更能反映基金经理本事的是长期的预测能力（IC）以及在当前的判断（Score）。在我看来，高IC是最重要的条件，否则不管Score多高，如果模型压根就不能有效的预测α（低IC），那么一切都是枉然。当然，如果有了高的IC，那么我们只需要找到在当前时刻的预测中Score高的那些股票买入即可。所以，所有靠选股为生的主动型基金经理大概都在较劲脑汁的想找到一个可以提高IC的α预测模型或者方法。</p>
<h3 id="α公式的变种"><a href="#α公式的变种" class="headerlink" title="α公式的变种"></a>α公式的变种</h3><p>Grinold最初提出的α三因素公式就如同前面小节所说明的那样，我们预测的是α本身，回归时是在时间维度对预测值f的时间序列和实际α的时间序列进行回归。然而预测α本身终究是困难的，更常见的做法是寻找能够挖掘α收益率的因子，使用因子本身的值对α建模，并通过<strong>截面回归</strong>来分析这类模型是否具有挖掘α的能力，这就是α三因素公式的变种。</p>
<p>截面回归是在给定的时间节点，使用所有股票在该时点在某一因子上的取值对下一时刻股票的α收益进行回归分析。令向量d为所有股票在时刻t的因子暴露，α为所有股票在t+1时刻的α收益率向量，利用线性回归便可以得到与本文第二节中相似的结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hrgj9y7qj30vs0eygph.jpg"></p>
<p>虽然公式看起来很相似，但这里的解释略有不同：E[α]是所有股票在t+1时刻的期望α收益，它应该近似的等于0。IC是该因子和α的截面相关系数，它衡量在t时刻，该因子是否具备优秀的选股能力。Volatility是所有股票α收益的截面波动率，它描述的是个股α收益率的差异性。Score衡量个股在因子上取值的强弱。</p>
<p>总结来说，<strong>因子和α收益率的相关性越高，个股α的差异性越大，我们的选股基础就越好</strong>。在这个基础上，只需要按照该因子选出分数高的股票就可以预期得到超额的α收益。如果所有股票的α都一样（Volatility &#x3D; 0）或者所有股票的因子取值都一样（Score &#x3D; 0），那么上式就相当于α &#x3D; 0，也就是说根本无法通过该因子选出含有超额α收益的股票；<strong>只有因子和α收益率的相关性越高，股票的差异性越大（α和因子的差异性都是越大越好），才越有可能找出α。</strong></p>
<p><strong>截面回归方法往往是一种事后验证</strong>。即我们在已知t+1时刻所有股票的α的前提下，用t时刻的因子取值对α进行回归，以此来衡量该因子在t时刻的选股能力。然而，<strong>由于不同因子之间有相关性，这种衡量方法其实也是有一定缺陷的</strong>。此外，t时刻的选股能力更不能保证在t+1时刻该因子仍然有同样的选股能力。<strong>要正确判断一个因子的选股能力仍然需要从时间维度上的考察通过该因子构造的纯因子投资组合（即排除其他因子对目标因子的干扰）是否可以持续的获得超额收益。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/10/31/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%8E%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%8E%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84/" class="post-title-link" itemprop="url">移动平均，你知道的与你不知道的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 20:02:38" itemprop="dateCreated datePublished" datetime="2019-10-31T20:02:38+08:00">2019-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:31:17" itemprop="dateModified" datetime="2022-09-10T15:31:17+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" itemprop="url" rel="index"><span itemprop="name">量化交易</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>移动平均（Moving Average，MA）</strong>，又称移动平均线，简称均线。作为技术分析中一种分析时间序列的常用工具，常被应用于股票价格序列。移动平均可过滤高频噪声，反映出中长期低频趋势，辅助投资者做出投资判断。</p>
<p>根据计算方法的不同，流行的移动平均包括<strong>简单移动平均、加权移动平均、指数移动平均</strong>，更高阶的移动平均算法则有<strong>分形自适应移动平均、赫尔移动平均</strong>等。这其中，简单移动平均又最为常见。下图为上证指数日线的5个不同计算窗口（20日，50日，120日，200日，300日）的简单移动平均线。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hn7t9e97j30yw0ge160.jpg"></p>
<p><strong>简单移动平均（Simple Moving Average,SMA）</strong> 就是对时间序列直接求<strong>等权重均值</strong>，因此使用简单。但其最令人诟病的就是它的<strong>滞后性</strong>。从上图不难看出，<strong>随着计算窗口T的增大，移动平均线越来越平滑，但同时也越来越滞后</strong>。以120日均线为例，在2015年6月份之后的大熊市开始了很长一段时间之后，120日均线才开始呈现下降趋势。如果我们按照这个趋势进行投资，那这个滞后无疑造成了巨额的亏损。</p>
<p><strong>事实上，任何移动平均算法都会呈现一定的滞后性。它以滞后性的代价换来了平滑性，移动平均必须在平滑性和滞后性之间取舍。</strong> </p>
<ul>
<li>滞后性是怎么产生的呢？</li>
<li>简单移动平均在时间上滞后多少呢？</li>
<li>有没有什么高级的移动平均算法能在保证平滑性的同时将滞后性减小到最低呢？</li>
</ul>
<p>这些就是本文要回答的问题。</p>
<h3 id="移动平均的本质"><a href="#移动平均的本质" class="headerlink" title="移动平均的本质"></a>移动平均的本质</h3><p><strong>移动平均的本质是一种低通滤波。</strong> 它的&#x3D;&#x3D;目的是过滤掉时间序列中的高频扰动，保留有用的低频趋势&#x3D;&#x3D;。如何从时间序列中抽取出真正的低频趋势呢？无论采取哪种移动平均算法，理论上的计算方法都相同，下面我们简要说明。同时，我们也会清晰地阐述&#x3D;&#x3D;该计算方法仅在理论上有效，而在实际应用中是无法实现的&#x3D;&#x3D;，并由此揭示产生滞后性的原因。</p>
<p>假设我们有一个时间序列y &#x3D; {…, yt-2, yt-1, yt, yt+1, yt+2, …}，如下图所示。另外，假设我们有一个作用在时域t上的过滤函数F（注：这个F的具体形式根据不同的移动平均算法而不同）。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hne63b6fj30zg08wgp6.jpg"></p>
<p>在理论上，在任意t时刻的低频滤波（用x<sub>t</sub>表示）在数学上可以表示为该时间序列y和过滤函数F在&#x3D;&#x3D;整个时域上的卷积&#x3D;&#x3D;，即</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnap2zdij30bq042mxf.jpg"></p>
<p>其中，F<sub>i</sub>为过滤函数F在时刻i的取值。由于在实际中不可能用到无穷多的数据，因此可以考虑给过滤加一个窗函数，即过滤函数F只在窗口长度T内有效、在窗口之外为0，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnf8g6xyj30z209a77p.jpg"></p>
<p>加入长度为T的窗函数后，在时刻t的低频滤波变为该时间序列y和过滤函数F在这个窗口内的卷积：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hqzk5ckbj30dw066js1.jpg"></p>
<p>然而，无论是否使用加窗函数，上述公式最大的问题是，&#x3D;&#x3D;在计算t时刻的低频分量时，利用到了未来的数据。&#x3D;&#x3D; 换句话说，&#x3D;&#x3D;理论上的低通滤波（或者移动平滑）必须要用事后数据，其假设所有数据都发生后再在全局上计算所有时点的低频分量。但这在实时数据中是不可能的，因为在任何当前时刻t，我们都没有未来数据可以利用。&#x3D;&#x3D;</p>
<p>正因如此，在实际应用中，我们无法使用t-(T-1)&#x2F;2到t+(T-1)&#x2F;2之间的数据，只能退而求其次使用t-(T-1)到t之间的数据。这相当于我们把计算低频趋势的过滤窗函数在时域上向左平移(T-1)&#x2F;2个单位，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr1d5uh1j311m0byq7b.jpg"></p>
<p>如此处理后，对于实时数据，在当前时刻t的低频滤波变为该时间序列y和过滤函数F在t-T+1到t之间的卷积：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr2dqh2tj30di056jrt.jpg"></p>
<p>没有未来数据便是滞后的根本原因。</p>
<p>&#x3D;&#x3D;对于简单移动平均来说，在窗口T内，过滤函数在每个时点的取值都是1&#x2F;T。利用上述公式计算得到的实际上是t-(T-1)&#x2F;2时刻（而非t时刻）的低频趋势，而我们把它当作t时刻的低频趋势使用，这便产生了(T-1)&#x2F;2的滞后。换句话说，当我们使用简单移动平均时，在当前时刻t，对于给定的时间窗口T，我们仅能求出t-(T-1)&#x2F;2时刻之前的低频趋势，而无法求出t-(T-1)&#x2F;2之后的低频趋势。&#x3D;&#x3D;这也解释了为什么时间窗口T越大，滞后(T-1)&#x2F;2越多。这就是为什么看股票数据里面MA20、MA30、MA50等日均线这种，计算均线的窗口T越大，得到的移动平滑曲线越滞后。</p>
<p>既然无论如何都没有未来数据，那么是否意味着我们就只能接受移动平均的滞后性呢？答案是否定的。换个角度来考虑这个问题，&#x3D;&#x3D;滞后性说明由简单移动平均计算得到的低频趋势对近期的最新数据不够敏感&#x3D;&#x3D;。这是由于它在计算低频趋势时，对窗口内所有的数据点都给予相同的权重。按着这个思路延伸，自然的想法就是&#x3D;&#x3D;在计算移动平均时，给近期的数据更高的权重，而给窗口内较远的数据更低的权重，以更快的捕捉近期的变化。&#x3D;&#x3D;</p>
<p>由此便得到了加权移动平均和指数移动平均。</p>
<h3 id="加权移动平均"><a href="#加权移动平均" class="headerlink" title="加权移动平均"></a>加权移动平均</h3><p>在<strong>计算加权移动平均（Weighted Moving Average, WMA）</strong> 时，窗口内的过滤函数的取值从当前数据到之前第T-1期的数据依次&#x3D;&#x3D;线性递减&#x3D;&#x3D;。因此，第t-i期的Fi为2(T-i)&#x2F;(T(T+1))，i &#x3D; 0,2,……,T-1。该权重是i的单调线性递减函数。下图为T&#x3D;15时不同i的取值对应的权重</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr345vpnj312k0scaeq.jpg"></p>
<p>在确定了权重后，t时刻的加权移动平均（记为WMAt）由下式得到：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr3vbqtwj30sm068myk.jpg"></p>
<p>值得一提的是，由于严格的按照线性递减，因此权重会最终在当前时刻之前的第T期时点衰减为0。</p>
<p>以上证指数过去10年的日数据为例，下图比较了T&#x3D;100时的简单移动平均和加权移动平均的过滤效果。可以看到，&#x3D;&#x3D;加权移动平均比简单移动平均对近期的变化更加敏感，尤其是在牛熊市转换的时候，加权移动平均的滞后性小于简单移动平均。&#x3D;&#x3D;但是，&#x3D;&#x3D;由于仅采用线性权重衰减，加权移动平均仍然呈现出滞后性&#x3D;&#x3D;。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr4kbdu1j311w0kqtl3.jpg"></p>
<h3 id="指数移动平均"><a href="#指数移动平均" class="headerlink" title="指数移动平均"></a>指数移动平均</h3><p><strong>指数移动平均（Exponential Moving Average, EMA）</strong> 和加权移动平均类似，但不同之处是各数值的加权按<strong>指数递减</strong>，而非线性递减。此外，在指数衰减中，无论往前看多远的数据，该期数据的系数都不会衰减到0，而仅仅是向0逼近。因此，指数移动平均实际上是一个<strong>无穷级数</strong>，即无论多久远的数据都会在计算当期的指数移动平均数值时有一定的作用，只不过离当前太远的数据权重非非常低，因此它们的作用往往可以忽略。</p>
<p>在实际应用中，t时刻的指数移动平均（记为EMA<sub>t</sub>）可以按如下方法得到：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr5abpfsj30ne062q3z.jpg"></p>
<p>其中alpha表示权重的衰减程度，取值在0和1之间。alpha越大，过去的观测值衰减的越快。虽然指数移动平均是一个无穷级数，但在实际应用时，我们也经常看到T期指数移动平均的说法。这里的T是用来计算alpha的参数，它不表示指数衰减在T期后结束。alpha和T的关系为alpha &#x3D; 2&#x2F;(T+1)。下图为T&#x3D;15时不同时刻的权重。可以看到，任何一期的权重都不会衰减到0。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr64dp51j31240skdlj.jpg"></p>
<p>下图比较了T&#x3D;100时简单移动平均、加权移动平均和指数移动平均的平滑效果。&#x3D;&#x3D;指数移动平均由于对近期的数据赋予了更高的权重，因此它比加权移动平均对近期的变化更加敏感，但这种效果在本例中并不显著，指数移动平均也存在一定的滞后。&#x3D;&#x3D;</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr6tfjncj31240lwk33.jpg"></p>
<p>当alpha&#x3D;1&#x2F;T时，得到的指数移动平均又称为<strong>修正移动平均（Modified Moving Average，MMA）</strong>或<strong>平滑移动平均（SMoothed Moving Average，SMMA）</strong>，它们在应用中也十分常见。比如，在计算技术指标ADX的时候，就应用到了平滑移动平均。</p>
<p>无论是加权还是指数移动平均，它们都是通过对近期的数值赋予更高的权重来提高低频趋势对近期变化的敏感程度。<strong>然而，它们的计算表达式（或算法结构）是固定的，在整个时间序列上的各个时点都使用同样的结构（即一成不变的权重分配方法）计算移动平均，而不考虑时间序列自身的特点。</strong></p>
<p><strong>一个优秀的移动平均算法计算出来的均线应在时间序列自身波动不明显的时点足够平滑，而在时间序列自身发生巨变时迅速捕捉、将滞后最小化</strong>。要想达到这种效果，就必须利用时间序列自身的特点。&#x3D;&#x3D;分形自适应移动平均算法就是这样一个有力的工具。&#x3D;&#x3D;</p>
<h3 id="分形自适应移动平均"><a href="#分形自适应移动平均" class="headerlink" title="分形自适应移动平均"></a>分形自适应移动平均</h3><p>顾名思义，<strong>分形自适应移动平均（FRactal Adaptive Moving Average，FRAMA）</strong> 利用了投资品价格序列的分形特征。简单的说，该算法通过一个简单的公式计算从时间序列从当前时点往前2T长度的时间窗口内的分形维数D，并利用分形维数进一步求解指数移动平均的参数alpha。</p>
<p><strong>分形维数描述时间序列的趋势，其取值在1到2之间，越大说明趋势越明显，越小说明时间序列越随机。因此，通过连续的计算时间序列局部的分形维数，该算法可以动态的、自适应的根据时间序列的特征计算平滑所用的参数。</strong> 由于alpha是D的减函数，因此D越大（趋势越明显），alpha越小，即指数平滑时对过去的数值衰减的越慢；D越小（随机性越强），alpha越大，即指数平滑时对过去的数值衰减的越快、对最新数据的变化越敏感。</p>
<p>具体的，对于当前时点t和给定的窗口T，该方法用到了三个时间窗口，即t到t-T+1（记为窗口W1，长度为T），t-T到t-2T+1（记为窗口W2，长度为T），以及t到t-2T+1（记为窗口W，长度为2T）。不难看出，W&#x3D;W1+W2。该方法的步骤如下：</p>
<p><strong>计算FRAMA均线的步骤</strong></p>
<ol>
<li>用窗口W1内的最高价和最低价计算 N1 &#x3D; (最高价 – 最低价) &#x2F; T</li>
<li>用窗口W2内的最高价和最低价计算 N2 &#x3D; (最高价 – 最低价) &#x2F; T</li>
<li>用窗口T内的最高价和最低价计算 N3 &#x3D; (最高价 – 最低价) &#x2F; (2T)</li>
<li>计算分形维数 D &#x3D; [log(N1+N2) – log(N3)] &#x2F; log(2)</li>
<li>计算指数移动平均的参数alpha &#x3D; exp(-4.6*(D-1))，并使其满足在0.01和1之间</li>
<li>将alpha带入指数移动平均的公式求解t时刻的FRAMA移动平均值</li>
</ol>
<p>下图比较了T&#x3D;100时指数移动平均以及分形自适应移动平均的平滑效果。很明显，由于利用了时间序列自身的分形特征，<strong>FRAMA均线对滞后性的提高非常明显，这意味着在价格趋势发生变化的时候它捕捉的更加及时。当然，取决于选取的参数，FRAMA均线在一些局部可能不够平滑，它体现了一种动态的对平滑度和灵敏度的取舍。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr7hkhrcj31240lwam6.jpg"></p>
<h3 id="赫尔移动平均"><a href="#赫尔移动平均" class="headerlink" title="赫尔移动平均"></a>赫尔移动平均</h3><p>最后，我们再介绍一种业界常用的高级移动平均算法，即<strong>赫尔移动平均（Hull Moving Average，HMA）</strong>。它由Alan Hull发明，故由此得名。该算法最大的特点是&#x3D;&#x3D;在减少滞后的同时有效的提高了均线的平滑程度&#x3D;&#x3D;。</p>
<p>在本文中，我们并不对它背后的逻辑做太多的剖析。我们直接给出它的计算步骤。对于给定的窗口T：</p>
<p><strong>计算HMA均线的步骤</strong></p>
<ol>
<li>计算窗口为T&#x2F;2的加权移动平均，并把结果乘以2（如果T&#x2F;2不是整数则取整）</li>
<li>计算窗口为T的加权移动平均</li>
<li>用第1步的结果减去第2部的结果，得到一个新的时间序列</li>
<li>以第3步得到的时间序列为对象，计算窗口为sqrt(T)，即根号T，的加权移动平均（如果根号T不是整数则取整）</li>
</ol>
<p>上述步骤的数学表达式为 HMA &#x3D; WMA((2*WMA(y, int(T&#x2F;2)) – WMA(y, T)), int(sqrt(T)))。</p>
<p>最后，比较T&#x3D;100时分形自适应移动平均和赫尔移动平均的平滑效果。令人惊喜的看到，<strong>HMA均线有着不输FRAMA均线的灵敏性（滞后性非常低），并且在局部也提高了平滑性，确实做到了在保证平滑性的同时最大的降低了滞后性</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hr83vzo3j31240kyk30.jpg"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>作为技术分析的利器，移动平均线人人都在看、人人都在用。可又有多少人想得清楚、用的明白呢？本文详尽的分析了移动平均技术的本质，揭示了滞后性产生的原因。通过对五种不同过滤技术的分析和对比，说明了高级的移动平均技术（比如FRAMA和HMA）可以有效的降低滞后性并保证均线的平滑性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/10/16/Flex%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/16/Flex%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Flex布局基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-16 21:36:26" itemprop="dateCreated datePublished" datetime="2019-10-16T21:36:26+08:00">2019-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:31:28" itemprop="dateModified" datetime="2022-09-10T15:31:28+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">开发手册</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>行内元素也可以使用 Flex 布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，设为 Flex 布局以后，子元素的<strong>float、clear和vertical-align属性</strong>将失效。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dh4ad2sj30fn099q2x.jpg"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<strong>main start</strong>，结束位置叫做<strong>main end</strong>；交叉轴的开始位置叫做<strong>cross start</strong>，结束位置叫做<strong>cross end</strong>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<strong>main size</strong>，占据的交叉轴空间叫做<strong>cross size</strong>。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p>以下6个属性设置在容器上。</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dlpyyloj30m405na9z.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可能有4个值。</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dnfwtogj30m607oa9u.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取三个值。</p>
<p>（1）nowrap（默认）：不换行。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80docemzsj30jg041aam.jpg"></p>
<p>（2）wrap：换行，第一行在上方。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dp0lvdtj30jg04x3yv.jpg"></p>
<p>（3）wrap-reverse：换行，第一行在下方。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dp5srs8j30jg04xmxf.jpg"></p>
<h4 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h4><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80drsndazj30hp0l70sn.jpg"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dtsdcksj30h50lu3yg.jpg"></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80dw5osdpj30h80lu0so.jpg"></p>
<p>该属性可能取6个值。</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="item-项目的属性"><a href="#item-项目的属性" class="headerlink" title="item 项目的属性"></a>item 项目的属性</h3><p>以下6个属性设置在item项目上。</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80e1ck8b3j30kv0dca9v.jpg"></p>
<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80e2hrykkj30ma05v3yf.jpg"></p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80e3rw65gj30jg041t8x.jpg"></p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效.</p>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80e68qcbdj30kn0aua9w.jpg"></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://justinzm.github.io/2019/10/08/Python%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E6%94%B6%E7%9B%8A%E7%8E%87%E3%80%81Alpha%E5%92%8CBeta%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="草根之明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="草根之明">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/Python%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E6%94%B6%E7%9B%8A%E7%8E%87%E3%80%81Alpha%E5%92%8CBeta%E5%80%BC/" class="post-title-link" itemprop="url">Python计算股票收益率、Alpha和Beta值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 21:02:40" itemprop="dateCreated datePublished" datetime="2019-10-08T21:02:40+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-10 15:32:57" itemprop="dateModified" datetime="2022-09-10T15:32:57+08:00">2022-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" itemprop="url" rel="index"><span itemprop="name">量化交易</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用Python计算股票的收益率，重点展示如何利用Python对日收益率数据向月、年收益率转换，然后演示个股Alpha和Beta值的计算。</p>
<h3 id="收益率"><a href="#收益率" class="headerlink" title="收益率"></a>收益率</h3><h4 id="单期收益率"><a href="#单期收益率" class="headerlink" title="单期收益率"></a>单期收益率</h4><p>单期（一个时期）的收益率计算方法如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r5o3ph4gj309u02owef.jpg"></p>
<p>其中，r 是收益率，pt 是时间 t 时的资产价格，p0 是初始时间的资产价格。我们利用 Python 程序来实现这个过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate_return = 102.0/100 - 1</span><br><span class="line">print(rate_return)</span><br></pre></td></tr></table></figure>
<p>假设我们买了 100 美元的股票，半年后它涨到了 102 美元。一年后，价格又涨到了 104 美元。那么我们应该如何计算它的总回报呢？首先，我们可以把它看做是一个时期的投资回报，即股票直接从 100 美元涨到了 104 美元，那么我们的回报率可以这样计算：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r5qpk26hj309602i748.jpg"></p>
<p>或者，我们也可以把这个当做两个时期的回报，即股票先从 100 美元涨到 102 美元，然后再从 102 美元涨到 104 美元，那么我们的回报率可以这样计算：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r5ru8pcqj30n202c3yn.jpg"></p>
<p>在这里，我们对一年的回报进行了两次计算，这种计算被称为半年复合。那么季度复合呢？让我们假设一下，每个季度末的股票价格分别为 p1，p2，p3和p4。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r5tognrlj30ma028q30.jpg"></p>
<p>我们在此计算的收益率称为累积回报或者总回报。它衡量一段时间内该资产的总回报。</p>
<p>现在考虑以下一个问题：我们有两个策略，策略A和策略B。我们将策略A运行了一年，累积回报率是20%。而我们运行策略B三年，累积回报率是65%。那么你觉得哪种策略的回报率更高呢？我们常用的比较方法是将所有收益转换为年复合收益率，无论每种策略的投资期限如何，我们都能通过这种方法来比较两种方法的收益率。我们通过计算获得策略 B 的年复合收益率如下：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r5wswmyhj30ck04qglr.jpg"></p>
<p>所以，策略A有更高的年复合收益率（compounding annual return）。</p>
<h4 id="对数收益率"><a href="#对数收益率" class="headerlink" title="对数收益率"></a>对数收益率</h4><p>年复合收益率，这是一种有效的回报率。但是，你也可以将其看做是一种 “假设回报”，因为策略 B 在三年的测试过程中，不可能每年的回报率都是 18.167% 。但是，我们可以假设策略B每年的回报率是 18.167%，所以它能达到三年的累积回报率是 65%。正如我们之前提到的，如果我们假设一个策略是季度复利的，那么季度有效收益率和年回报之间的关系为：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r62m11jpj308a024t8m.jpg"></p>
<p>更一般的说，如果一年内复合的时间是 n，而年回报率是 r，那么我们可以得到如下的关系式：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r63tly11j308802a3yf.jpg"></p>
<p>现在想象一下股市，我们的资产是每秒都在变化，甚至每毫秒都是在变化的。如果符合的时间或 n 接近无限大，则称为连续复合。计算公式如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r657kgftj30ac028weg.jpg"></p>
<p>从上面的方程中，我们知道如果我们假设复合收益是连续的：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r677nbabj307y0280sn.jpg"></p>
<p>我们对等式两边都取自然对数 ln ，则：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7r67ki419j30au022gll.jpg"></p>
<p>在这里我们获取了对数收益率，或者称为连续复合收益。这在计算回报时经常被使用，因为一旦我们采用资产价格的对数，我们就可以通过简单的减法来计算对数回报。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 先引入后面可能用到的包</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from scipy import stats</span><br><span class="line">import tushare as ts</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 正常显示画图时出现的中文和负号</span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span><br></pre></td></tr></table></figure>

<h4 id="收益率转化"><a href="#收益率转化" class="headerlink" title="收益率转化"></a>收益率转化</h4><p>对日期进行处理，分别将日对数收益率转化为月和年收益率。主要有三个步骤：</p>
<p>1.估计股票每日对数收益率；<br>2.加总对数收益率到每月（年）；<br>3.将月（年）收益率转化为百分比收益率  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stock = &#x27;sh&#x27;</span><br><span class="line">df = ts.get_k_data(stock, start=&#x27;2010-01-03&#x27;)</span><br><span class="line"># 使用tushare中的get_k_data()得到的数据框索引是顺序数字，而不是日期序列，因此，为分析方面，需要进行变换，即使用“date”作为索引。</span><br><span class="line">df.set_index([&#x27;date&#x27;], inplace=True)</span><br></pre></td></tr></table></figure>
<p>步骤一：计算对数收益率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算的时候第一个数成为缺失值，删掉</span><br><span class="line">lograte = np.log(df.close/df.close.shift(1))</span><br></pre></td></tr></table></figure>

<p>步骤二：加总对数收益率到每日</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">month = []</span><br><span class="line">index = lograte.index</span><br><span class="line"></span><br><span class="line">for i in range(0, np.size(lograte)):</span><br><span class="line">    month.append(index[i][:7])</span><br><span class="line"></span><br><span class="line">y = pd.DataFrame(lograte.values, index=month, columns=[&quot;月收益率&quot;])</span><br></pre></td></tr></table></figure>

<p>步骤三：将日收益率转化为月收益率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret_monthly = y.groupby(y.index).sum()</span><br><span class="line">print(ret_monthly)</span><br><span class="line"></span><br><span class="line">#          月收益率</span><br><span class="line"># 2019-05 -0.060128</span><br><span class="line"># 2019-06  0.027285</span><br><span class="line"># 2019-07 -0.015689</span><br><span class="line"># 2019-08 -0.015904</span><br><span class="line"># 2019-09  0.033933</span><br></pre></td></tr></table></figure>

<p><strong>将日收益率转化为年收益率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stock = &#x27;601318&#x27;</span><br><span class="line">df = ts.get_k_data(code=stock, ktype=&#x27;D&#x27;, autype=&#x27;qfq&#x27;, start=&#x27;2007-03-01&#x27;)</span><br><span class="line"></span><br><span class="line">df.set_index([&#x27;date&#x27;], inplace=True)</span><br><span class="line"></span><br><span class="line"># 计算的时候第一个数成为缺失值，删掉</span><br><span class="line">lograte = np.log(df.close/df.close.shift(1))[1:]</span><br><span class="line"></span><br><span class="line">year = []</span><br><span class="line">index = lograte.index</span><br><span class="line"></span><br><span class="line">for i in range(0, np.size(lograte)):</span><br><span class="line">    year.append(index[i][:4])</span><br><span class="line"></span><br><span class="line">y = pd.DataFrame(lograte.values, index=year, columns=[&quot;年收益率&quot;])</span><br><span class="line"></span><br><span class="line">ret_annual = np.exp(y.groupby(y.index).sum())-1</span><br><span class="line">print(ret_annual)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="草根之明"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">草根之明</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/justinzm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;justinzm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3907721@qq.com" title="E-Mail → mailto:3907721@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">草根之明</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
